var store = [{
        "title": "SGIS-shpToGeojson",
        "excerpt":"SGIS에서 받은 지도데이터(.shp)를 geojson으로 변경하는 작업 내용   2018년에 쓴 글을 재업로드하였습니다.   지도데이터 가공 과정     shapefile을 simplify를 진행.                     우선 mapshaper라는 shp파일 에디팅 툴로 편집. GUI온라인툴도 있음. 본인은 node CUI로 진행.           $ mapshaper -i 전환할 파일 \\             encoding=euc-kr  \\             -simplify weighted 0.5% \\ // 0.5%로 단순화             -o format=shapefile \\             바뀐 파일명.shp                           shapefile(R) -&gt; geojson 전환            ogr2ogr npm 라이브러리를 사용                    커맨드 :             $ ogr2ogr -f GeoJSON -t_srs crs:84 [geo json파일명] [shp파일명]                                    중요설명 : -t_srs crs:84 로 해줘야 제대로 projection이 됨(지도 투영법).           -&gt; 0.5%로 했더니 3~4MB인데 렌더링 시 느리다면 더 작게하는 것을 추천           -&gt; mapshaper로도 geojson을 만들 수 있지만 투영법 옵션이(-proj) 잘 안먹혀서 ogr2ogr, geo2topo를 적용함.                           만일 geojson에서 한글이 깨져서 나오는 경우     한글인코딩 문제            shpfile의 인코딩 에러. QGIS를 설치(로컬에서 shpfile을 수정할 수 있음)       QGIS 상단네비게이션 바의 “속성 테이블” 열기를 클릭해보면 한글 깨지는 것을 확인가능.       링크 로 들어가서 지시대로 하면 shpfile 인코딩에러 수정…. 아… 내 삽질….       shpfile로 다운로드는 해당 레이어를 우클릭  후 다른이름으로 저장하기 누르면 됨. 이후 다시 mapshaper, ogr2ogr 하면 됨.           projection(좌표계) 문제            막상 위의 한글문제를 해결해도 geojson파일을 열어보면 좌표계가 127.023168001711184, 37.578041688607954 의 형태가 아님.                이 문제는 한글 인코등 해결처럼 속성에서 좌표계를 스크롤 맨 밑의 사용자 정의 좌표계를           +proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m +no_defs                    로 정의 해야함. 정의한 다음 다시 다른 이름을 다운로드 진행.                   geojson -&gt; topojson으로 전환     npm topojson-client 설치   커맨드 : geo2topo [geo-json파일] &gt; [topo-json파일]   topojson 라이브러리는 현재 커맨드라인 툴이 사용불가. 반드시 topojson-client 설치 후 geo2topo로 할것. -Note also that topojson/topojson is no longer the command-line tools for manipulating TopoJSON — that’s all been put in the topojson/topojson-client repository.(출처)   -&gt; 0.5%로 했더니 3~4MB인데 렌더링 시 느리다면 더 작게하는 것을 추천   -&gt; mapshaper로도 topojson, geojson을 만들 수 있지만 투영법 옵션이(-proj) 잘 안먹혀서 ogr2ogr, geo2topo를 적용함.      느낀점 및 팁            gis데이터 가공은 projection(투영법) 설정이 중요.           활용가능한 결과물            통계청 파일 및 GeoJson 가공 데이터 파일       이름_simple.shp : 0.5%로 simplify한 shapefile       이름_geo.json : 가공한 GeoJson 파일       index.html : 예제 코드 browser-sync 같은 툴로 Application 형태로 띄워야 에러가 안남. 이유는 모르겠지만 포트로 안 띄우면 에러.           주의사항            geojson까지만 변경함. topojson까지는 변경하지 않음.          ","categories": ["DataProcessing"],
        "tags": ["ShapeFile","GeoJson","TopoJson","데이터 가공"],
        "url": "https://seunghyum.github.io/dataprocessing/SGIS-shpToGeojson/",
        "teaser":null},{
        "title": "[CodingTest] 별(*) 박스 만들기",
        "excerpt":"문제 설명     별(*) 박스 만들기   입력값 a(rows)와 b(cols)에 해당하는 별박스 만들기   예시 - 1  입력  4 2  출력  **** ****   예시 - 2  입력  3 5  출력  *** *** *** *** ***   내가 작성한 정답  solution(a,b) {   return (\"*\".repeat(a) + \"\\n\").repeat(b); }  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/star-box/",
        "teaser":null},{
        "title": "[CodingTest] 직사각형의 한점 좌표값 유추하기",
        "excerpt":"문제   직사각형을 만드는 데 필요한 4개의 점 중 3개의 좌표가 주어질 때, 나머지 한 점의 좌표를 구해 전체 좌표값들을 구해야한다.  점 3개의 좌표가 들어있는 배열 v가 매개변수로 주어질 때( v = [[x축 좌표, y축 좌표], … ] ), 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 return 하도록 solution 함수를 완성하라. 단, 직사각형의 각 변은 x축, y축에 평행하며, 반드시 직사각형을 만들 수 있는 경우만 입력으로 주어짐. 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 [x축 좌표, y축 좌표] 순으로 담아 return.   입출력 예                  insert       result                       [[1, 4], [3, 4], [3, 10]]       [1, 10]                 [[1, 1], [2, 2], [1, 2]]       [2, 1]           내가 작성한 답안   function solution(v) {     const rangeX = [             Math.max(v[0][0],v[1][0],v[2][0]),              Math.min(v[0][0],v[1][0],v[2][0])         ],         rangeY = [             Math.max(v[0][1],v[1][1],v[2][1]),              Math.min(v[0][1],v[1][1],v[2][1])         ],         stringfiedResult = [             JSON.stringify([rangeX[0], rangeY[0]]),             JSON.stringify([rangeX[0], rangeY[1]]),             JSON.stringify([rangeX[1], rangeY[0]]),             JSON.stringify([rangeX[1], rangeY[1]])         ],         stringfiedV = [             JSON.stringify(v[0]),              JSON.stringify(v[1]),             JSON.stringify(v[2])         ];     let answer     stringfiedResult.map(val =&gt; {         if(stringfiedV.indexOf(val) == -1) {             console.log(\"val : \", val)             answer = JSON.parse(val)         }     })     return answer }   내 답안풀이   직사각형이라면 모든 좌표들의 x축값은 a와 b 둘 중 하나이고 y축값 역시 c,d 둘 중 하나라고 생각했다. 그래서  [a,c], [b,c],  [a,d], [b,d]  의 형태일거라고 생각했다.   그래서 세 점의 좌표값들중  x축값들의 최소값, 최대값이 a와 b이고 =&gt; rangeX  y축값들의 최소값, 최대값이 c와 d이다. =&gt; rangeY   stringfiedResult는 그값들의 좌표값들이다.  stringfiedResult에서 없는 좌표값을 찾는 것이 내가 생각한 답이었다.   다른 사람들의 풀이   YanghaKoo 님이 푸신 식을 보면 더 간단하다.  function solution(v) {   var a = {}   var b = {}   const answer = []      v.forEach(r =&gt; {     if(a[r[0]]){       a[r[0]] = a[r[0]] +1     }else{       a[r[0]] = 1     }      if(b[r[1]]){       b[r[1]] = b[r[1]] +1     }else{       b[r[1]] = 1     }   });    for(var i in a){     if(a[i] === 1) {       answer.push(Number(i))       break;     }   }      for(var i in b){     if(b[i] === 1) {       answer.push(Number(i))       break;     }   }    return answer }   연산   v = [[1,4], [3,4], [3,10]]                  r       a       b                       [1,4]일때       {“1”:1}       {“4”: 1}                 [3,4]일때       {“1”:1, “3”:1}       {“4”: 2}                 [3,10]일때       {“1”:1, “3”:2}       {“4”: 1, “10”: 1}           연결배열로 input 값으로 주어진 각 숫자들의 출현빈도를 뽑고  뽑은 것들중 1번 출현한 숫자의 x,y축 값을 리턴하여 답을 내고 있다.   내 답의 경우 JSON.stringfy 매서드로 배열을 문자화시켜 그것들을 비교하고 있다.  문자화 연산의 비용을 고려하자면 연결배열로 문제를 해결하는 방법이 효율적이다.   실제 jsben.ch에서 테스트해본결과 내 로직보다 50% 더 효율적이었다.  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Rectangle-empty-point/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 1번 오픈채팅방 문제 with Javascript",
        "excerpt":"오픈채팅방     문제 바로가기 링크   카카오의 설명 블로그       나의 답안      function solution(record) {   let accounts = [], events = [], answer = [];        function setEnterProcess(message, userId, nickName) {       const findAccountByUserId = accounts.find(a =&gt; a.userId == userId)        if(findAccountByUserId &amp;&amp; findAccountByUserId.nickName !== nickName) findAccountByUserId.nickName = nickName;       else accounts.push({userId, nickName});                events.push({message, userId});   }        function setChangeProcess(userId, nickName) {       const findAccountByUserId = accounts.find(a =&gt; a.userId == userId)       findAccountByUserId.nickName = nickName   }        function setLeaveProcess(message, userId) {      events.push({message, userId})    }    record.map(r =&gt; {       const msgArray = r.split(\" \"),             message = msgArray[0],             userId = msgArray[1],             nickName = msgArray[2];       if(message == \"Enter\") setEnterProcess(message, userId, nickName);       else if(message == \"Change\") setChangeProcess(userId, nickName);       else if(message == \"Leave\") setLeaveProcess(message, userId);   })        events.map(e =&gt; {       const findAccountByUserId = accounts.find(a =&gt; a.userId == e.userId)       if(e.message == \"Enter\") answer.push(`${findAccountByUserId.nickName}님이 들어왔습니다.`)       else if(e.message == \"Leave\") answer.push(`${findAccountByUserId.nickName}님이 나갔습니다.`)   })        return answer; }                 테스트       Mocha 라이브러리 사용.     test.js      const assert = require('assert'); describe('test1', () =&gt; { describe('#연결배열', () =&gt; {   it('문제에서 제시한 테스트', () =&gt; {     assert.equal(       JSON.stringify(solution([\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\"])),       JSON.stringify([\"Prodo님이 들어왔습니다.\", \"Ryan님이 들어왔습니다.\", \"Prodo님이 나갔습니다.\", \"Prodo님이 들어왔습니다.\"])     );   });    it('기존 테스트에 추가한 로직을 추가한 테스트', () =&gt; {     assert.equal(       JSON.stringify(solution(         [           \"Enter uid1234 Muzi\",            \"Enter uid4567 Prodo\",           \"Leave uid1234\",           \"Enter uid1234 Prodo\",           \"Change uid4567 Ryan\",           \"Leave uid1234\",           \"Enter uid9990 Dave\",           \"Change uid9990 Kean\",           \"Enter uid1234 Jane\",         ]       )),       JSON.stringify([         \"Jane님이 들어왔습니다.\",          \"Ryan님이 들어왔습니다.\",          \"Jane님이 나갔습니다.\",          \"Jane님이 들어왔습니다.\",         \"Jane님이 나갔습니다.\",           \"Kean님이 들어왔습니다.\",          \"Jane님이 들어왔습니다.\"       ])     );   }); }); });                  느낀점  처음엔 events와 accounts를 같은 곳에 담고 관리하려고 했다.  [   {     {message: \"Enter\", userId: \"uid1234\", nickName: \"Muzi\"},     {message: \"Enter\", userId: \"uid4567\", nickName: \"Prodo\"},     ....   } ]  그러다보니 한 유저가 닉네임을 변경할때마다 모든 객체들을 탐색해야했다.  문제를 풀고 카카오의 해설 을 보니 “두 연결배열에 각각 accouts와 events에 담아 관리하면 쉽다”는 해설을 보고 코드를 다시 짰다.   해설을 보고나니 너무 간단해 허탈했다. 아직 갈길이 먼 것 같다.  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-open-chatting-room/",
        "teaser":null},{
        "title": "[CodingTest] Algospot - Anagram 문제",
        "excerpt":"  내가 작성한 답안  function solution(v) {   const inputs = v.split(\"\\n\"),          inputsLength = inputs.length;   let answer = \"\";    for(let i=1;i&lt;inputsLength;i++) {     let elements = inputs[i].split(\" \");     if(elements[0] == elements[1]) answer += \"No.\\n\";     else {       answer += elements[0].split(\"\").sort().reduce(reducer) == elements[1].split(\"\").sort().reduce((accumulator, currentValue) =&gt; accumulator + currentValue) ? \"YES\\n\" : \"No.\\n\";     }   }   return answer }    더 좋은 방식 찾기 - O(NlogN) 보다 낮은방법   Baekjoon 문제 - Anagram Generater     바로가기 링크     내가 작성한 답안  function solution(v) {   const inputs = v.split(\"\\n\"),          inputsLength = inputs.length;   let answers = \"\";      for(let i=1;i&lt;inputsLength;i++) { // 여러줄의 단어들 반복     const strings = inputs[i].split(\"\"),           stringsLength = strings.length;     let stringsStats = {}      for(let j=0;j&lt;stringsLength;j++) { // {a: 2, b:1, c: 1}       if(stringsStats[strings[j]]) stringsStats[strings[j]] += 1       else stringsStats[strings[j]] = 1     }      let initArray = []     for(s in stringsStats) {  // [a,b,c]       if(stringsStats[s] &gt; 0) initArray.push(s)       else continue;     }          let answer = \"\";     console.log(\"initArray : \", initArray)     console.log(\"stringsStats : \", stringsStats)     console.log(\"reduceStrings : \", reduceStrings(initArray, stringsStats, answer))   }   // return answer }  function reduceStrings(strings, stringsStats, answer) {   let stringArray = [...strings],       stats = {...stringsStats};    stringArray.forEach((sa)=&gt; {     newStringArray = [];      answer += sa;     stats[sa] -= 1;          for(s in stats) {       if(stats[s] &gt; 0) newStringArray.push(s);     }     console.log(\"sa : \", sa)     console.log(\"stringArray : \", stringArray)     console.log(\"stats : \", stats)     console.log(\"newStringArray : \", newStringArray)     console.log(\"answer : \", answer)     console.log(\"=========\")     if(newStringArray.length &gt; 0) reduceStrings(newStringArray, stats, answer);     else (answer += \"\\n\");   }) }   느낀점  처음 anagram 문제를 접한것은 같이 js를 공부하던 친구가 회사면접에서 받은 질문에서 시작되었다.  막상 나도 “그때 나였더라면 제대로 풀 수 있었을까?” 라는 생각에 접하게되었다.  아마 Youtube에 올라온 구글 면접 예시 영상의 분위기 였을것 같다. 링크   그다음 비슷한 문제가 어디있지 하며 찾은게 Algospot의 문제와 Backjoon 사이트의 문제였다.   Algospot의 문제는 생각했을때 비교적 간단했다. 두 문자열이 주어지고 같은지 비교만 하면 되었다.  하지만 Backjoon 사이트의 아나그램 문제를 풀어보며 “내가 js를 잘 이해하고 있는건가?” 라는 생각이 들었다.   Backjoon 사이트의 아나그램 문제는 하나의 문자열을 주고 그것에 해당하는 아나그램을 산출하라는 문제였다.  제한 조건은     알파벳 순서대로 나열할것   대소문자 구분할것   입력받은 철자들 중 중복되는 철자들이 있을경우, 중복해서 출력할 수 있으나 하나만 출력하라. ex) google -&gt; ggoole이 하나만 출력   문자열 풀이방식     받은 문자열을 array로 쪼개어 sorting하여 abc순으로 구성한다.   for문 재귀함수로 구성하여 n!로 문제를 해결   이라고 생각했다. 하지만 이럴경우 중복되는 문자들이 있을때 적절하게 문제를 해결하지 못했다.  가령 [a,a,b,c]가 있을떄 첫번째 문자가 b가 나올경우 [a,a,c]가 남는다는 것이다.  a는 1개로 취급되어야하는데 2개로 취급된다는 것이다.   내가 삽질을 하며 얻은 해결방법은     [a,a,b,c] 의 문자열을 루프를 돌때마다 하나씩 꺼내들고   {a:2, b:1, c:1}같은 형식의 객체로 루프를 돌때마다 문자열의 개수를 카운팅하고   카운팅한 객체들 중 0이 아닌 문자들을 배열에 담고[a,b,c]   1번을 다시 반복하며 배열에 문자가 하나도 없을때까지 반복한다. 는 것이었다.   하지만 이 루프를 돌며 반복하는 코드에서 스코프 문제가 발생했다.  ","categories": ["CodingTest"],
        "tags": ["Javascript","Algospot"],
        "url": "https://seunghyum.github.io/codingtest/Algospot-anagram/",
        "teaser":null},{
        "title": "[CodingTest] 매일 프로그래밍 - 피보나치 배열 2019-03-25",
        "excerpt":"      // 처음 답 function solution(n) {   if(n &lt; 2) return 0   let initN = [1,1], output = 0, result = 0;    while(n &gt; initN[0] + initN[1]) {     output = initN[0] + initN[1]     initN = [initN[1], output]     if(output%2 == 0) result += output   }    return result }  // 수정 후 function solution(n) {   if(n &lt; 2) return 0   let x = 1, y = 1, sum = 0;    while(n &gt; x) {     if(x%2 == 0) sum += x     let z = x + y     x = y     y = z   }    return sum }    ","categories": ["CodingTest"],
        "tags": ["Javascript","EverydayProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Every-Day-Programming-1/",
        "teaser":null},{
        "title": "[CodingTest] 매일 프로그래밍 - 2019-03-26",
        "excerpt":"문제  정수 배열(int array)가 주어지면 가장 큰 이어지는 원소들의 합을 구하시오. 단, 시간복잡도는 O(n).   Given an integer array, find the largest consecutive sum of elements.   예제  Input: [-1, 3, -1, 5]  Output: 7 // 3 + (-1) + 5    Input: [-5, -3, -1]  Output: -1 // -1    Input: [2, 4, -2, -3, 8]  Output: 9 // 2 + 4 + (-2) + (-3) + 8   내 풀이  난 중복된 수만 제오하고 합쳐라 라는 건줄 앎…. 문제에 대한 설명이 좀 더 정확했으면…  function solution(input) {   return [...new Set(input)].reduce((i, j) =&gt; i + j) }   정답  시간 복잡도: O(n)  공간 복잡도: O(1)  int solution(int[] arr) {   int maxSum = arr[0];   int currentSum = arr[0];   for(int i = 1; i &lt; arr.length; i++) {     currentSum = Math.max(currentSum + arr[i], arr[i]);     maxSum = Math.max(currentSum, maxSum);   }   return maxSum; }  ","categories": ["CodingTest"],
        "tags": ["Javascript","EverydayProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Every-Day-Programming-2/",
        "teaser":null},{
        "title": "Sorting Algorithms",
        "excerpt":"읽고 정리해야하는 기사     링크   퀵소트   버블소트   ","categories": ["Sorting Algorithms"],
        "tags": ["Sorting Algorithms"],
        "url": "https://seunghyum.github.io/sorting%20algorithms/Sorting-Algorithms/",
        "teaser":null},{
        "title": "[CodingTest] 배열의 두 값을 합하여 k값 만들기",
        "excerpt":"문제  list라는 행렬과 k라는 자연수가 주어짐. list의 두 값을 합하여 k값을 만들 수 있으면 true, 없으면 false를 리턴해라.  보너스 : 한줄 표기   입력  let list = [3, 9, 10, 14], k = 12 solution(list, k) // =&gt; true   내가 풀어본 풀이  방법1 - 처음 풀어본 답안  function solution(list, k) {   for(let i = 0; i&lt;list.length;i++) {     for(let j = 1; j&lt;list.length;j++) {       if(list[i] + list[j] == k) return true      }   }   return false } // jsBench 기준 // 198,911,753 ops/s ±0.73% // fastest  풀어보고 나니 이 방식보다 더 좋은 방식. 한줄에 풀 수 있는 방식이 있나 궁금해졌다. 시간복잡도는 O(N2)이다.   방법2 - 한줄에 풀어본 답안  function solution(list, k) {   return list.some((currentVal,idx) =&gt; list.slice(idx+1).includes(k - currentVal)) } // jsBench 기준 // 17,822,052 ops/s ±1.82% // 91.04% slower (for문 중첩보다)  최대한 한줄에 풀어봄.  이렇게 할경우 한줄에는 쓸 수 있지만     루프(n)를 돌며 계속해서 slice를 해야한다는점.   루프(n)를 돌며 계속해서 includes매서드로 해당 인자가 포함되어있는지를 체크해야한다는점  때문에 효율적인지에 대한 의문이 있다.  차라리 중첩 for문으로 O(N2)번 푸는게 낫지 않을까 라는 생각이 든다.  benchmark를 해도 for문 중첩이 9 더 좋은 퍼포먼스를 내었다. jsBench   slice 매서드와 includes 매서드가 움직이는 방법식을 확인해보고 위의 한줄코드가 더 좋은 것인지 파악해봐야겠다.   slice 매서드 폴리필  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice  // 필요한 부분만 가져옴    Array.prototype.slice = function(begin, end) {   // 정의되지 않은 끝 인자로 IE &lt;9가 불만해진다.   end = (typeof end !== 'undefined') ? end : this.length;    // 네이티브 Array 객체의 경우 네이티브 slice 함수를 사용합니다.   if (Object.prototype.toString.call(this) === '[object Array]'){     return _slice.call(this, begin, end);    }    // object와 같은 배열을 위해 우리는 스스로 처리한다.   var i, cloned = [],     size, len = this.length;    // \"begin\"에 대한 음수 값을 처리합니다.   var start = begin || 0;   start = (start &gt;= 0) ? start : Math.max(0, len + start);    // \"end\"에 대한 음수 값을 처리합니다.   var upTo = (typeof end == 'number') ? Math.min(end, len) : len;   if (end &lt; 0) {     upTo = len + end;   }    // 슬라이스의 실제 예상 크기   size = upTo - start;    if (size &gt; 0) {     cloned = new Array(size);     if (this.charAt) {       for (i = 0; i &lt; size; i++) {         cloned[i] = this.charAt(start + i);       }     } else {       for (i = 0; i &lt; size; i++) {         cloned[i] = this[start + i];       }     }   }    return cloned; };  해당 배열을 for문으로 돌면서 조건과 일치하는 엘리먼트들을 가져옴.   includes 매서드 폴리필  // https://tc39.github.io/ecma262/#sec-array.prototype.includes if (!Array.prototype.includes) {   Object.defineProperty(Array.prototype, 'includes', {     value: function(searchElement, fromIndex) {        .       .       .        // 7. Repeat, while k &lt; len       while (k &lt; len) {         // a. Let elementK be the result of ? Get(O, ! ToString(k)).         // b. If SameValueZero(searchElement, elementK) is true, return true.         if (sameValueZero(o[k], searchElement)) {           return true;         }         // c. Increase k by 1.          k++;       }        // 8. Return false       return false;     }   }); }  위를 보면 includes매서드는 while문으로 배열을 탐색하고 찾으면 리턴하는 구조.   방법1의 경우 O(N2)보다 방법2는 O(N3) n번의 시간복잡도를 더 가지고 있다.  풀이해보자면  지금까지 내가 이해한 시간복잡도를 공식화 하자면     방법1 : 2n2 + 2n - 1 =&gt; O(N2)     function solution(list, k) { for(let i = 0; i&lt;list.length;i++) { // n   for(let j = 1; j&lt;list.length;j++) { // n * (n-1)     if(list[i] + list[j] == k) return true // (n-1) * (n-1)   } } return false }           방법2 : n * (n-1) * (n-1) =&gt; O(N3)     function solution(list, k) {  return list.some((currentVal,idx) =&gt; { // n   list.slice(idx+1) // n * (n-1)       .includes(k - currentVal) // n * (n-1) * (n-1) }) }           다른 사람들의 풀이 - Set을 이용  function solution(list, k) {   let seen = new Set();   for (let num of list) {     if(seen.has(k-num)) return true // O(1)     seen.add(num)   }   return false } solution([3, 9, 10, 14], 12)  iterate 하면서 이터레이팅 한 수들을 기억하여 찾아내는 방법.  배열의 요소들을 반복하면서 set에 우리가 지금까지 봤던 수들을 넣고 (seen 변수) 각 수마다 K값이 되기위해 필요한 수들을 seen에서 찾기   Set으로 이터레이팅하고있는 엘리먼트들을 기억하며 반복문을 돌린다. 이때의 시간복잡도는 O(N)라고 한다. ==&gt; 이해가 잘안간다. 결국 has 매서드로 다시 seen을 한바퀴 도는게 아닌가?   다른 사람들의 풀이 - 이진탐색으로 구하기 - 시간복잡도 O(nlogN) + O(1)  function binarySearch (list, value) {   // initial values for start, middle and end   let start = 0,       stop = list.length - 1,       middle = Math.floor((start + stop) / 2);    // While the middle is not what we're looking for and the list does not have a single item   while (list[middle] !== value &amp;&amp; start &lt; stop) {     if (value &lt; list[middle]) {       stop = middle - 1     } else {       start = middle + 1     }      // recalculate middle on every iteration     middle = Math.floor((start + stop) / 2)   }    // if the current middle item is what we're looking for return it's index, else return -1   return (list[middle] !== value) ? -1 : middle }  function solution(list, k) {   list.sort((a,b) =&gt; a-b); // O(logN)    for(let i=0;i&lt;list.length;i++) { // // O(n)     let target = k-item,         j = binarySearch(list, target); // O(n*logN)      if(j == -1) continue; // O(n*logN*1)     else if(j != i) return true;     else if(j + 1 &lt; list.length &amp;&amp; list[j + 1] == target) return true     else if(j - 1 &gt;= 0 &amp;&amp; list[j - 1] == target) return true   }   return false }   개념적으로 보자면 그래프에서 보듯이 어느 시점에서는 O(nlogN)이 O(n)보다 효율적일 수 있다.  그래서 두가지 방법을 혼용하는 것이 나은것 같다.   이해하는데 필요한 개념 &amp; 궁금한점     시간복잡도 Big O 표기법 개념   binary search 개념 및 구현            구현 관련 블로그 설명           성능을 제대로 비교해볼 수 있는 Benchmark 라이브러리 적용.   어느시점에서 nlogN이 N보다 효율인지 알 수 있나?  ","categories": ["CodingTest"],
        "tags": ["DailyProgramming","Javascript","BinarySearch","Set"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-1/",
        "teaser":null},{
        "title": "[DataType] Map & Set",
        "excerpt":"Set vs Array - 관련기사     Set            유일값들의 배열이 필요할때(distinct)       집합의 개념이 필요할때(차집합, 교집합 등등 자체 메서드들이 많음.)       index가 필요 없을때       Array에서 중복값을 없앨때 =&gt; new Set([1,1,2,3]) // 1,2,3       set의 add()는 O(n)의 시간복잡도가 소요되지만, Array의 push는 N(1)의 시간복잡도.           Array            요소들의 순서(order)가 필요할때       index가 필요할때 -&gt; Binaory Search           Map vs Object 관련기사     Map            key가 어떤타입도 될 수 있음.       저장한 key의 순서가 유지됨.       Object의 변형. Object와 동일 연산시 비용이 더 들어감.           Object            순수한 object의 나열일때 적합.       property에서 function 로직이 있을때 사용.       json 지원           읽어고 정리해야할 기사     data-structures-in-javascript   링크  ","categories": ["Data Type"],
        "tags": ["Data Type"],
        "url": "https://seunghyum.github.io/data%20type/Map-Set/",
        "teaser":null},{
        "title": "Big O",
        "excerpt":"Big O     CheetSheet   CheetSheet  ","categories": ["Big O"],
        "tags": ["Big O"],
        "url": "https://seunghyum.github.io/big%20o/Big-O/",
        "teaser":null},{
        "title": "[CodingTest] i를 제외한 배열 요소들의 곱",
        "excerpt":"문제  정수 배열이 주어지면 인덱스 i에 해당하는 값 이외의 모든 값들의 곱인 배열을 구하여라.  보너스 : 나눗셈을 안쓰고 풀기   예시  [1,2,3] =&gt; [6,3,2] [1,2,3,4,5 ] =&gt; [120, 60, 40, 30, 24]   나눗셈이 있는 풀이법  // 2n =&gt; O(n) function solution(arr) {   const max = arr.reduce((a,b)=&gt;a*b); // n   let answer = [];   for(let el of arr) { // n + n     answer.push(max/el)   }   return answer }   나눗셈 없는 풀이법  // n^2 = N(n^2) function solution(arr) {   return arr.map(el =&gt; // n     arr.reduce((a,b) =&gt; { // n       return el == b ? a : a*b     },1)   ) }   느낀점     O(N2) 이외의 풀이법은 생각이 나지 않음.   답변 및 해설  function solution(arr) {     // Generate prefix solution     let prefix_products = []     for(el of arr) {       if (prefix_products.length &gt; 0) prefix_products.push(prefix_products[prefix_products.length-1] * el)       else prefix_products.push(el)     }     console.log(\"prefix_products : \", prefix_products)      // Generate suffix solution     let suffix_products = []     for(el of [...arr].reverse()) {       if(suffix_products.length &gt; 0) suffix_products.push(suffix_products[suffix_products.length-1] * el)       else suffix_products.push(el)     }     suffix_products = [...suffix_products].reverse();     console.log(\"suffix_products : \", suffix_products)      // Generate result     let result = []     for (let i=0; i&lt;arr.length; i++) {       if(i == 0) result.push(suffix_products[i + 1]) // 첫 엘리먼트       else if (i == arr.length - 1) result.push(prefix_products[i - 1]) // 마지막 엘리먼트       else result.push(prefix_products[i - 1] * suffix_products[i + 1])     }     console.log(\"result : \", result)     return result }  해결방법 : 루프를 돌면서 해당 인덱스(i)의 prefix(앞부분들)와 suffix(뒷부분들)의 값들을 구해서 곱하는 방법.   prefix는 i번째의 앞부분들의 수의 곱  suffix는 i번째의 뒷부분들의 수의 곱   result는 루프를 돌면서 i번째 앞부분들의 곱과 뒷부분들의 곱에 해당하는 element 값들 간의 곱   아이디어     n2이외의 방법을 위해 여러가지 n을 만들어 풀기.   i번째의 앞부분들의 곱과 뒷부분들의 곱에 해당하는 array추출.  ","categories": ["CodingTest"],
        "tags": ["DailyProgramming","Javascript","BinarySearch","Set"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-2/",
        "teaser":null},{
        "title": "[CodingTest] 일련의 숫자들 중 비어있는 값찾기",
        "excerpt":"문제  이 문제는   주어지는 정수 배열은 1이 공차인 일련의 숫자.  이어지는 값이 중 일련의 숫자값이 가장 길고     값이 비었거나   가장 작은 이어지는 값을 찾아라.   입력값 : integer array 주의사항 : 중복값, 음수도 포함될 수 있음.   예시  [3, 4, -1, 1] =&gt; 2  [1, 2, 0] =&gt; 3   내 풀이법  // O(logN) function solution(arr) {   let sortedArr = arr.sort((a,b) =&gt; a - b),       longestNumberIdx = 0,       longestNumberLength = 0,       lengthNumbering = 1; // logN    for(let i=0;i&lt;sortedArr.length;i++) { // n     if(Math.abs(sortedArr[i+1] - sortedArr[i]) == 1) {       lengthNumbering += 1;       if(i == sortedArr.length-2) {         longestNumberIdx = sortedArr.length-1;         longestNumberLength = lengthNumbering;       }     } else if(Math.abs(sortedArr[i+1] - sortedArr[i]) == 0 || sortedArr[i+1] &gt; 0) {       lengthNumbering = 1;       if(longestNumberLength &lt; lengthNumbering) {          longestNumberIdx = i;         longestNumberLength = lengthNumbering;       }     } else {       lengthNumbering = 1;     }   }   let index = longestNumberIdx - longestNumberLength +1   return sortedArr[index] &gt; 0 ? index : sortedArr[longestNumberIdx] + 1 }  // 테스트용 데이터 solution([-1, 1, 3, 4]) solution([1, 2, 0]) solution([1, 2, 3, 4]) solution([1, 2, 3, -2,-3])  solution([-1,-2,-3,1,2])  solution([1,2,3,3,4])  solution([ 2, 3, 4, 5, 5, 6, 7 ])      루프를 돌며 연속된 수가 가장 많은 배열의 마지막 엘리먼트의 인덱스(longestNumberIdx), 연속되는 길이(longestNumberLength)를 구하고 마지막에 해당 배열의 첫 엘리먼트 -1의 값이 양수면 반환,  음수면 배열의 마지막 엘리먼트의 +1를 반환하는 형식  으로 풀었다.   이렇게 풀었을때 중복되는 값(duplicates)의 값을 걸러내지 못했다.  계속 if문으로 예외처리를 해주며 풀어야할 것 같아 좋은 풀이법이 되지 못했다.   좋은 풀이법  문제의 복잡성을 위해 양수 이상일때의 숫자만 구하도록 하는 방법이 좋다.   function solution(nums) {   nums.forEach((num, i)=&gt;{     console.log(\"***num : \", num)     console.log(\"***i : \", i)     while (i + 1 != nums[i] &amp;&amp; 0 &lt; nums[i] &amp;&amp; nums[i] &lt;= nums.length) {       let v = nums[i];       console.log(`before nums[${i}] : ${nums[i]}, nums[${v - 1}] : ${nums[v - 1]}`)       // nums[i] = nums[v - 1];       // nums[v - 1] =  v;       [nums[i], nums[v - 1]] = [nums[v - 1], nums[i]]       console.log(`after nums[${i}] : ${nums[i]}, nums[${v - 1}] : ${nums[v - 1]}`)       if(nums[i] == nums[v - 1]) break;     }   });   console.log(\"nums : \", nums)   for(let i=1;i&lt;=nums.length; i++) {     console.log(`${nums[i]} != ${i}`)     if(nums[i] != i) return i;   }   return nums.length + 1; }   ","categories": ["CodingTest"],
        "tags": ["Javascript","DailyProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-3/",
        "teaser":null},{
        "title": "[Syntax] 새로 알게된 파이썬 문법 정리",
        "excerpt":"chaning comparison  파이썬은 chaning comparison이라는 신기한 문법이 있다. 참고  if a &lt; b and b &lt; c :   (...)  라는 구문이  if a &lt; b &lt; c :   (...)  으로 연산된다. 직관적인 문법이 인상적. Comparison operator Chaining 이라고 불린다.   Slice operater  특징  문자열, tuples, dictionaries, lists 에 모두 적용가능.   [start:end]  [1:5] is equivalent to \"from 1 to 5\" (5 not included) [1:] is equivalent to \"1 to end\" [len(a):] is equivalent to \"from length of a to end\"  List slicing   list[시작:끝:스텝]   list = [1,2,3,4,5,6,7]  &gt;&gt;&gt; list[0:3] # 끝 인덱스 값에 해당하는 요소값은 포함하지 않음. [1,2,3]  &gt;&gt;&gt; list[-5:-2] # 뒤에서 5번째 요소값부터 뒤에서 2번째 요소값 직전까지 [3,4,5]  &gt;&gt;&gt; list[-2:-1] # 뒤에서 2번째 요소값부터 뒤에서 1번째 요소값 직전까지 [6]  &gt;&gt;&gt; list[0:7:2] [1,3,5,7]   ","categories": ["Python","Syntax"],
        "tags": ["Python"],
        "url": "https://seunghyum.github.io/python/syntax/Python-Syntax/",
        "teaser":null},{
        "title": "[Network] 네트워크 공부내용 정리",
        "excerpt":"참고      책            그림으로 배우는 http &amp; network       http 완벽가이드               참고 사이트            그림으로 배우는 http &amp; network 정리글       http 완벽가이드 읽는법       zerocho 님 블로그 시리즈       wiki 백과(URI, URL, UDP)               글 작성 로그 및 수정 계획      2019.04.06 그림으로 배우는 http &amp; network 정리글 블로그를 읽고 정리한 글            실제 책(그림으로 배우는 http &amp; network) 읽고 한번 더 정리                    ch2 -&gt; 트랜잭션 생성에 따른 통신 과정 - 2019.04.15           ch3  -&gt; 데이터 타입에 따른                       http 완벽 가이드 다시 읽고 정리 &lt;- http 완벽가이드 읽는법       CORS, CORB 에러 정리       쿠키 / 캐시 정리               TCP/IP   인터넷과 관련된 프로토콜을 모아놓은 것   대부분, IP프로토콜을 사용한 통신에서 사용되고 있는 프로토콜을 총칭해서 TCP/IP라고 함.  설계를 편하게 하고 유지보수를 위해서 계층화가 되어있음.     4계층            애플리케이션 계층 - 유저에서 제공되는 에플리케이션 (FTP, DNS, HTTP)       트랜스포트 계층 - 에플리케이션 계층에 네트워크로 접속되어 있는 컴퓨터사이의 데이터흐름을 제공(TCP, UDP)       네트워크 계층 - 네트워크 상에서 패킷의 이동을 다룸. 여러대의 컴퓨터랑 네트워크 기기사이에서 길을 찾는 것(IP)                    패킷 : 전송하는 데이터의 최소 단위                       링크 계층 - 네트워크의 하드웨어적인 면 (케이블 등등)      HTTP 데이터 -&gt; TCP 헤더 -&gt; IP 헤더 -&gt; Eternet 헤더           IP      배송을 담당. 개개의 패킷을 상대방에게 전달. IP주소와 MAC(변경 불가)주소를 통해서 통신   어느 누구도 길에대한 정확한 위치를 알고 있지 않음(물어물어 찾아감)   네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것. 각 기기에 할당되는 것이 아니라 기기에 장착된 각각의 네트워크용 하드웨어에 할당 됨. 즉, 복수의 네트워크하드웨어를 장착한 기기는 복수의 주소 할당.   MAC(Media Access Control Address) 주소 :  IEEE에서 표준화된 LAN 방식의 기기는 모두 같은 형식의 주소를 사용하는데 이 주소를 가르킴. MAC주소를 사용하여 목적지를 찾아갈때는 ARP라는 프로토콜이 사용됨   IP주소는 변경가능하나, MAC주소는 변경불가. ```shell $ ipconfig   이더넷 어댑터 이더넷:   연결별 DNS 접미사. . . . :    링크-로컬 IPv6 주소 . . . . : fe80::c160:8c0f:cef4:7ce8%13    IPv4 주소 . . . . . . . . . : 192.168.1.1    서브넷 마스크 . . . . . . . : 255.255.248.0    기본 게이트웨이 . . . . . . : 192.168.0.1  위의 IPv4주소가 내 컴퓨터의 IP주소. 192.168.1까지가 네트워크 주소, 맨뒤의 1이 호스트 주소.  네트워크 주소란? : 공통적인 부분(중복이 되는 부분)  호스트 주소란? : 식별할 수 있는 부분(중복이 없고 유일무이한)   예시 :  경기도 용인시 수지구 죽전동 A아파트 101동 1301호 네트워크 주소 : 경기도 용인시 수지구 죽전동 A아파트 101동 호스트 주소 : 1301호   IP는 32자리 2진수로 표현.  예시 172.16.254.1 | 172. | 16. | 254. | 1 | |—-|—-|—-|—-| | 10101100. | 00010000. |  11111110. | 00000001 |    ## TCP(Transfer Control Protocol)  * 신뢰성을 담당   * 바이트 스트림 서비스   \\: 큰 데이터를 보내기위에 TCP세그먼트라고 불리우는 단위 패킷으로 작개 분해하여 관리하는것. 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할.   * TCP Three way hand shaking (STN/ACK 플래그 사용)   \\: SYN으로 보내면 SYN/ACK 플래그로 패킷 수신한 사실을 전하면 ACK 플래그를 다시 보내 완료되었음을 전송. 도중에 끊키면 다시 반복  ![TCP Three way hand shaking (STN/ACK 플래그 사용)](/assets/images/3way_hand_shake.png)    ## DNS(Domain Name System)  : 도메인을 주면 IP주소를 반환해줌   ## HTTP  * 클라이언트(웹브라우저)에서 서버까지 일련의 흐름을 결정하는 프로토콜 * HTTP자체는 잘 변하지 않음. 현재는 1997년 공개된 HTTP/1.1을 대부분 쓰고있음. 2.0이 탄생되었지만 표준화까지 시간이 오래걸림  &gt; [HTTP 세션에 대한 설명](https://tobewiseys.tistory.com/72) &gt; [쿠키와 세션](https://sdevstudy.tistory.com/27)  ## URI, URL  URI(Uniform Resource Identifiers)   스키마를 나타내는 리소스를 식별하기 위한 식별자.   스키마: 리소스를 얻기위한 수단에 이름을 붙이는 방법. (http, ftp, mailto, file, telnet 등).      * Uniform     * 통일된(Uniformity) 서식을 결정하는 것. 여러가지 종류의 리소스 지정을 구별없이 같은 맥락에서 사용할 수 있게 한다. (응??) 또한, 새로운 스키마(http:와 ftp등) 도입을 용이하게 함 * Resource     * 식별가능한 모든 것. (도큐먼트 파일, 이미지, 서비스(ex. 오늘의 일기예보) 등 다른 것과 구별할 수 있는 것은 모두 리소스) 단일한 부분만 아니라 복수의 집합도 리소스임 * Identifier     * 식별자. 식별 가능한 것을 참조하는 오브젝트.   URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해  URL은 리소스의 장소(네트워크상의 위치)를 나타낸다.  URL은 URI의 서브셋이다. (URI = URL + URN)  &lt;br&gt;&lt;br&gt; URL 포맷&lt;br&gt;&lt;br&gt; ![URL_syntax](/assets/images/URL_syntax.png) &lt;br&gt;&lt;br&gt; URL 설명&lt;br&gt;&lt;br&gt; ![URL_explain](/assets/images/URL_explain.png) &lt;br&gt;&lt;br&gt; 예시  http://user:pass@www.aaa.com:80/dir/index.html?uid=12#head1  &lt;br&gt; 예시 풀이  http://    user:pass   @www.aaa.com     :80     /dir/index.html    ?uid=12           #head1 스키마(http),   자격정보,       서버주소,      서버포트,     계층적파일경로,     쿼리문자열,     프래그먼트식별자(#head1) ```      스키마            리소스를 얻기위해 사용하는 프로토콜을 지시.       대소문자 무시, 마지막에 콜론(:)이 붙음.       “data:”, “javascript:”같이 데이터와 프로그램도 지정 가능.           자격정보(=크리덴셜)            서버로부터 리소스를 취득하려면 자격정보가 필요.       유저명과 패스워드 지정. 이것은 옵션.           서버주소 : DNS이름(www.aaa.com)이나, IPv4주소(192.168.1.1)나, IPv6주소([0:0:0:0:0:0:0:1])를 쓸 수 있음.   서버포트 : 서버의 접속대상이 되는 네트워크 포트 번호 지정. 이것도 옵션. 생략시 디폴트 포트가 사용   계층적 파일경로 : 특정 리소스를 식별하기 위해 서버상의 파일 패스를 지정.   쿼리문자열 : 파일 패스로 지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리문자열을 사용. 옵션값   프래그먼트 식별자 : 취득한 리소스에서 서브리소스 (도큐먼트 중간에 위치)를 가리키기 위해서 사용. 옵션값   UDP와 TCP 비교[편집]   TCP는 데이터를 주고 받을 양단 간에 먼저 연결을 설정하고 설정된 연결을 통해 양방향으로 데이터를 전송하지만, UDP는 연결을 설정하지 않고 수신자가 데이터를 받을 준비를 확인하는 단계를 거치지 않고 단방향으로 정보를 전송한다.     신뢰성 - TCP는 메시지 수신을 확인하지만 UDP는 수신자가 메시지를 수신했는지 확인할 수 없다.   순서 정렬 - TCP에서는 메시지가 보내진 순서를 보장하기 위해 재조립하지만 UDP는 메시지 도착 순서를 예측할 수 없다.   부하 - TCP보다 속도가 일반적으로 빠르고 오버헤드가 적다.       간단한 프로토콜 HTTP   하나의 트랜젝션     TCP커넥션 연결 (쓰리웨이 핸드쉐이킹)     HTTP요청   HTTP응답     TCP커넥션 종료         HTTP는 스테이트리스(Stateless)프로토콜이다. 과거에 교환했던 리퀘스트와 리스폰스의 상태를 관리하지 않음.  이점도 있지만 이로인한 문제를 해결하기 위한 시스템 : 쿠키   쿠키 - HTTP 프로토콜의 스테이트리스 단점을 보완.  클라이언트 상태 파악하기 위함.   서버에서 리스폰스로 보내진 Set-Cookie라는 헤더필드에 의해 쿠키를 클라이언트에 보존.   다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키값을 넣어서 송신.   서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버상의 기록을 확인해서 이전 상태를 알 수 있음.      HTTP 매서드      GET : 리소스 획득   POST : 엔티티 전송.   PUT : 파일전송. FTP에 의한 파일전송과 같이 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하다록 요구. 인증기능이 없어서 REST를 사용하는 경우에 사용. entity의 전체(ex - 모든 fields)를 바꿈(update)   PATCH : entity의 일부만 바꿈(ex - 일부 fields)를 바꿈.            참고(스프링에서의 정의) PUT replaces an existing entity. If only a subset of data elements are provided, the rest will be replaced with empty or null.           DELETE : 파일 삭제. PUT매서드와 반대. 인증기능이 없어서 REST를 사용하는 경우에 사용.   HEAD : GET과 같은 기능이지만 메시지 바디는 반환 안함. URI 유효성과 리소스 갱신 시간을 확인하는 목적으로 사용.   OPTIONS : 제공하고 있는 메소드의 문의. 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하는데 사용함.   TRACE : 경로조사. 프록시등을 중계할떄 추적위해 사용. 크로스 사이트 트레이싱(XST) 같은 공격을 일으킬 수 있으므로 거의 안쓰임. “Max-Forwards”라는 헤더 필드에 수치를 포함시켜 요청하면 서버를 통과할때마다 그 수치를 줄여나감. 수치가 0이 된 곳을 끝으로 200 OK 리스폰스 보냄.   CONNECT : 프록시에 터널링 요구. TCP 통신을 터널링 시키기 위해서 사용함. 주로 SSL, TLS등의 프로토콜로 암호화된 것을 터널링 시키기 위해서 사용.   HTTP 상태 코드   참고 : 위키백과 HTTP 상태코드     1xx 정보   2xx 성공(Success)   3xx 리다이렉트(Redirection)   4xx 클라이언트 에러(Client Error)            401(권한 없음): 이 요청은 인증이 필요하다. 서버는 로그인이 필요한 페이지에 대해 이 요청을 제공할 수 있다. 상태 코드 이름이 권한 없음(Unauthorized)으로 되어 있지만 실제 뜻은 인증 안됨(Unauthenticated)에 더 가깝다. ex) CORS에러       403(Forbidden, 금지됨): 서버가 요청을 거부하고 있다. 예를 들자면, 사용자가 리소스에 대한 필요 권한을 갖고 있지 않다. (401은 인증 실패, 403은 인가 실패라고 볼 수 있음)       404(Not Found, 찾을 수 없음): 서버가 요청한 페이지(Resource)를 찾을 수 없다. 예를 들어 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.           5xx 서버 에러(Server Error)            500(내부 서버 오류): 서버에 오류가 발생하여 요청을 수행할 수 없다.       501(구현되지 않음): 서버에 요청을 수행할 수 있는 기능이 없다. 예를 들어 서버가 요청 메소드를 인식하지 못할 때 이 코드를 표시한다.       502(Bad Gateway, 불량 게이트웨이): 서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 잘못된 응답을 받았다.           웹의 여러 애플리케이션   프록시 : 클라이언트와 서버사이에 위치한 HTTP 중개자   서버와 클라이언트 사이에서 중계 프로그램. 웹 보안, 어플리케이션 통합, 성능 최적화에 쓰임.  모든 웹 트래픽 흐름속에서 신뢰할 만한 중개자 역할을 한다.  요청과 응답을 필터링한다.  무언가를 다운받을 때 애플리케이션 바이러스를 검출하거나, 초등학교 학생들에게서 성인 콘텐츠를 차단한다.       캐시 : 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고   프록시서버와 클라이언트 로컬디스크에 보관된 리소스 사본.  자주 찾는 것의 사본을 저장해두는 특별한 종류의 http프락시 서버다.  리소스를 가진 서버에 엑세스를 줄이는 것이 가능하기 때문에 통신량과 통신시간을 절약할 수 있다.        게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹서버   다른 서버들의 중개자. 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용.  게이트웨이는 언제나 스스로가 리소스를 갖고있는 진짜 서버인 것처럼 요청을 다룸.  클라이언트는 자신이 게이트웨이와 통신하는 것을 알지못함.  예를들어 HTTP/FTP 게이트웨이는 GTP URI에 대한 HTTP요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옴. 받아온 문서는 HTTP메시지에 담겨 클라이언트에게 보냄.        터널 : 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시   에이전트 : 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트   ","categories": ["Network"],
        "tags": ["Network"],
        "url": "https://seunghyum.github.io/network/Network/",
        "teaser":null},{
        "title": "[CodingTest] 숫자값 인코딩 조합구하기",
        "excerpt":"문제  알파벳의 인코딩 값을    a = 1  b = 2  c = 3  .  .  z = 26   으로 매핑.   숫자값 n이 주어지고 그 숫자에 대한 알파벳 디코딩 값 조합의 개수를 구하여라.   단, ‘0020’ 과 같이 앞에 ‘0’이 나오는 값은 주어지지 않음.   This looks like a problem that is ripe for solving with recursion. First, let’s try to think of a recurrence we can use for this problem. We can try some cases:   ””, the empty string and our base case, should return 1. “1” should return 1, since we can parse it as “a” + “”. “11” should return 2, since we can parse it as “a” + “a” + “” and “k” + “”. “111” should return 3, since we can parse it as: “a” + “k” + “” “k” + “a” + “” “a” + “a” + “a” + “”. “011” should return 0, since no letter starts with 0 in our mapping. “602” should also return 0 for similar reasons. We have a good starting point. We can see that the recursive structure is as follows:   If string starts with zero, then there’s no valid encoding. If the string’s length is less than or equal to 1, there is only 1 encoding. If the first two digits form a number k that is less than or equal to 26, we can recursively count the number of encodings assuming we pick k as a letter. We can also pick the first digit as a letter and count the number of encodings with this assumption. def num_encodings(s):     if s.startswith(‘0’):         return 0     elif len(s) &lt;= 1: # This covers empty string         return 1   total = 0  if int(s[:2]) &lt;= 26:     total += num_encodings(s[2:])  total += num_encodings(s[1:]) return total However, this solution is not very efficient. Every branch calls itself recursively twice, so our runtime is O(2n). We can do better by using dynamic programming.   All the following code does is repeat the same computation as above except starting from the base case and building up the solution. Since each iteration takes O(1), the whole algorithm now takes O(n).   from collections import defaultdict   def num_encodings(s):     # On lookup, this hashmap returns a default value of 0 if the key doesn’t exist     # cache[i] gives us # of ways to encode the substring s[i:]     cache = defaultdict(int)     cache[len(s)] = 1 # Empty string is 1 valid encoding   for i in reversed(range(len(s))):     if s[i].startswith('0'):         cache[i] = 0     elif i == len(s) - 1:         cache[i] = 1     else:         if int(s[i:i + 2]) &lt;= 26:             cache[i] = cache[i + 2]         cache[i] += cache[i + 1] return cache[0]   예시   input : n = '111'  // 'aaa', 'ka', 'ak output : 3   나의 풀이법  function solution(n) {   //'111' // 1,1,1 &amp; 11,1 &amp; 11,1   숫자 하나의 값은 무조건 가능. O(1)로 마지막 결과값에 + 1   // '101' -&gt; 10,1 만 가능.   // '1001' -&gt; 불가능.   // '444' -&gt; 4,4,4 값만 가능    // '1271' -&gt; 1,2,7,1 &amp; 12,7,1  // 뒤의 27, 71은 디코딩 안됨    // '1202' -&gt; 1,20,2 만 됨.    // '120220' -&gt; 1,20,2,1 &amp;&amp; 1,20,21 만 됨.    // method 1 O(n)방식   let nArr = n.split(''),       output = 0; // 한 자리 숫자들만 일때    // 두자리 숫자 조합으로 고를 경우   for(let i=0;i&lt;nArr.length;i++) {     ouput     let current = Number(nArr[i]),         next = Number(nArr[i+1]),         nnext = Number(nArr[i+2]),         count = 1;     // 첫번째 숫자만     if(current==1 &amp;&amp; nnext&gt;0 || !nnext) {            }     else if(current==2 &amp;&amp; next&lt;7 &amp;&amp; nnext&gt;0 || !nnext) {      }   } }  function countArr  ()  ","categories": ["CodingTest"],
        "tags": ["Javascript","DailyProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-4/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 2번 실패율 문제 with Javascript",
        "excerpt":"오픈채팅방     문제 바로가기 링크   카카오의 설명 블로그     나의 첫답안  function solution(N, stages) {   let st = stages, stats = [];   for(let i=1;i&lt;N+1;i++){ // n     let selectedNumbers=0, obj = {};     st = st.filter((s)=&gt;{ // n * n       if(s == i) selectedNumbers++;       else return true;     });     obj.name = i;     obj.per = (st.length == 0 ? 1 : selectedNumbers/st.length);     stats.push(obj)   }   stats.sort((a,b)=&gt; a.per - b.per &gt;= 0 ? -1 : 1) // n^2 + logN   return stats.map(s =&gt; s.name) // -&gt; O(n^2) }   나의 수정한 답안  function solution(N, stages) {   let eaStats = {}, perStats = [];    for(let el of stages) { // Array 인자값들의 갯수 통계를 내고 = easStats -&gt; n     if(!eaStats[el]) eaStats[el] = 1;     else eaStats[el]++;   }    let stageUsers = stages.length;    for(let i=1;i&lt;N+1;i++){ // 갯수통계(eaStats)를 확률들의 통계(perStats)로 다시 변환하고 -&gt; 2n     let perStatsObj = {}     if(!eaStats[i]) {       perStatsObj.name = i;       perStatsObj.per = 0;       perStats.push(perStatsObj)     } else {       perStatsObj.name = i       perStatsObj.per = stageUsers == 0 ? 1 : eaStats[i]/stageUsers;       stageUsers = stageUsers - eaStats[i];       perStats.push(perStatsObj)     }   }    perStats.sort((a,b)=&gt; a.per - b.per &gt;= 0 ? -1 : 1) // 확률들의 통계(perStats)로 다시 변환하고 -&gt; 2n + nlogN   return perStats.map(s =&gt; s.name) // -&gt; O(nlogN) }   결과 비교   나의 첫답안    나의 수정한 답안       공부해야할 자료  sort 매서드는 merge sort라고 한다. 관련링크  다른 sort들의 특징과 장점을 봐야겠다.     JS Interview Question   Sort Algorithms with Javascript  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-failure-rate/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 1번 오픈채팅방 문제 with Javascript",
        "excerpt":"후보키     문제 바로가기 링크   카카오의 설명 블로그     나의 답안   function solution(relation) {     //1. for 문으로 object로 통계값 추출 + set으로 중복되는 값있는지 확인. 후보키 가능열을 열마다 체크          const numOfCols =  relation[0].length,             numOfRows = relation.length;     let answer = 0,         stats = [],         candidateKeyCols = [];     for (let i=0;i&lt;numOfCols;i++){         let rowsOfCol = new Set(),             indexArr = [];         for (let j=0;j&lt;numOfRows;j++){             // if(rowsOfCol) indexArr.push             rowsOfCol.add(relation[j][i])         }         if(rowsOfCol.size == numOfRows) {             answer++;             candidateKeyCols.push(i)         }     }     console.log(\"answer : \", answer)     //2. 1번의 후보키가능 열을 제외하고 (통계값이 2인) 각 열마다 중복되는 값이 있는 경우,      // 해당 튜플들의 다른 값들을 비교.         }   알아야할 개념      깊이 우선 검색(DFS - Deep-First-Search)            정리글           다른사람의 답안 (bit를 이용한 연산)   function solution(relation) {   const tuples = relation[0].length,     rows = relation.length;   const cKey = [];    for (let i = 1; i &lt;= 1 &lt;&lt; tuples; i++) {     const set = new Set();      for (let j = 0; j &lt; rows; j++) {       let key = \"\";        for (let k = 0; k &lt; tuples; k++) {         if (i &amp; (1 &lt;&lt; k)) {           key += relation[j][k];         }       }       set.add(key);     }      // 유일성 및 최소성 체크     if (rows === set.size &amp;&amp; isMinimal(cKey, i)) {       cKey.push(i);     }   }   return cKey.length; }  // 최소성 체크 function isMinimal(cKey, index) {   for (let i = 0; i &lt; cKey.length; i++) {     if ((cKey[i] &amp; index) == cKey[i]) return false;   }   return true; }  const relation = [   [\"100\", \"ryan\", \"music\", \"2\"],   [\"200\", \"apeach\", \"math\", \"2\"],   [\"300\", \"tube\", \"computer\", \"3\"],   [\"400\", \"con\", \"computer\", \"4\"],   [\"500\", \"muzi\", \"music\", \"3\"],   [\"600\", \"apeach\", \"music\", \"2\"] ];  console.log(solution(relation));  ","categories": ["CodingTest","Kakao"],
        "tags": ["Javascript","Kakao"],
        "url": "https://seunghyum.github.io/codingtest/kakao/Kakao-Candidate-Key/",
        "teaser":null},{
        "title": "[CodingTest] 2019 네이버 핵데이 코드테스트 문제3 with Javascript",
        "excerpt":"문제3  문제를 알려줄 수 없다는 답변 받음. github에서 네이버 핵데이 검색하면 나옴.   내가 작성한 답변 - 아래로 꺾인선만 구하기  function solution(N) {   let maxUnderCurvedPoint = N[0];   for(let i=0;i&lt;=N.length;i++) {     if(N[i]&gt;N[i+1] &amp;&amp; maxUnderCurvedPoint &gt; N[i]) maxUnderCurvedPoint = N[i];   }   for(let i=N.length-1;i&gt;=0;i--) {     if (maxUnderCurvedPoint &lt; N[i]) return i-1   } }  풀이해석          예시              생각했던 과정         부족했던 점  N = [0,4,-1,3,10] // 이 경우를 제대로 못구함.  내 답은 단순히 아래로꺾은선 만을 고려하였고 위로꺾은 선은 고려하지 않았다.  그래서 위의 예시처럼 첫번째 위로꺾은 선이 앞쪽에 배치될 경우 걸러내지 못했다.   수정한 답안1 - 위로꺾인선, 아래로꺾인선 구하기  function solution(N) {   let maxUnderCurvedPoint = N[0], maxUpperCurvedPoint = N[0];   for(let i=0;i&lt;=N.length;i++) {     if(N[i]&lt;N[i+1] &amp;&amp; maxUnderCurvedPoint &lt; N[i]) maxUnderCurvedPoint = N[i];     else if(N[i]&gt;N[i+1] &amp;&amp; maxUpperCurvedPoint &lt; N[i]) maxUpperCurvedPoint = N[i]; // 추가   }   for(let i=N.length-1;i&gt;=0;i--) {     if (maxUnderCurvedPoint &lt; N[i] &amp;&amp; maxUpperCurvedPoint &lt; N[i]) return i; // 수정   } }  부족한 점  다시생각해보니 위로 꺾인선만 고려하면 쉽게 답이 나옴.   수정한 답안2 - 위로꺾인선만 구하기  function solution(N) {   let maxUpperCurvedPoint = N[0];   for(let i=0;i&lt;=N.length;i++) {     if(N[i]&gt;N[i+1] &amp;&amp; maxUpperCurvedPoint &gt; N[i]) maxUpperCurvedPoint = N[i]; // 추가   }      for(let i=N.length-1;i&gt;=0;i--) {     if (maxUpperCurvedPoint &lt; N[i]) return i; // 수정   } } console.log(\"solution([-5,-5,3,10]) : \", solution([-5,-5,3,10])) console.log(\"solution([3,-5,5,10]) : \", solution([3,-5,5,10]))   느낀점  답에 대한 테스트케이스를 여러개 생각해서 검토하지 않아서 오류를 놓침.  여러가지 테스트케이스를 해보고 오류점검하는 버릇이 좀 더 들어야함.  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Naver-Hackday-Test-3/",
        "teaser":null},{
        "title": "[CodingTest] 2019 네이버 핵데이 코드테스트 문제2 with Javascript",
        "excerpt":"문제2  문제 받으면 작성할 예정.   내가 작성한 답변  let input = {   x: 4   l: {     x:5,      l: {       x: 4,       l: {         x: 5,         l: null,         r: null       },       r: null     },     r: null   },   r: {     x: 6,     l: {       x: 1,       l: null,       r: null,     },     r: {       x: 6,       l: null,       r: null,     }   } }  function solution (T) {   T. }  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Naver-Hackday-Test-2/",
        "teaser":null},{
        "title": "[CodingTest] 2019 네이버 핵데이 코드테스트 문제1 with Javascript",
        "excerpt":"문제1  문제를 알려줄 수 없다는 답변 받음. github에서 네이버 핵데이 검색하면 나옴.   내가 작성한 답변  function solution(A) {   const oppositeGroupA = new Set([1,6]),         oppositeGroupB = new Set([2,5]),         oppositeGroupC = new Set([3,4]);      let stats = {},       maxEl = A[0],        maxCount = 1,       answer = 0;   // 가장 많이 중복되는 el을 기준.   // return = 기준 숫자의 반대편 숫자의 갯수 * 2 + 다른 숫자면들의 개수들    for(let i = 0; i &lt; A.length; i++) {     let el = A[i];     if(stats[el] == null) stats[el] = 1;     else stats[el]++;       if(stats[el] &gt; maxCount) {       maxEl = el;       maxCount = stats[el];     }   }   for(let s in stats) {     let NumberS = Number(s);     if(maxEl == NumberS) continue;     else if(oppositeGroupA.has(maxEl) &amp;&amp; oppositeGroupA.has(NumberS)) answer += stats[s] * 2;     else if(oppositeGroupB.has(maxEl) &amp;&amp; oppositeGroupB.has(NumberS)) answer += stats[s] * 2;     else if(oppositeGroupC.has(maxEl) &amp;&amp; oppositeGroupC.has(NumberS)) answer += stats[s] * 2;     else answer += stats[s];   }   return answer; }  console.log(\"1,2,3 : \", solution([1,2,3])) console.log(\"1,1,6 : \", solution([1,1,6])) console.log(\"1,6,2,3 : \", solution([1,6,2,3])) console.log(\"1,1,2,3,6 : \", solution([1,1,2,3,6]))   수정한 답변  function solution(A) {   let stats = {},       maxEl = A[0],        maxCount = 1,       answer = 0;          for(let i = 0; i &lt; A.length; i++) {     let el = A[i];     if(stats[el] == null) stats[el] = 1;     else stats[el]++;       if(stats[el] &gt; maxCount) {       maxEl = el;       maxCount = stats[el];     }   }    for(let s in stats) {     let NumberS = Number(s);     if(maxEl == NumberS) continue;     else if(maxEl + NumberS === 7) answer += stats[s] * 2;     else answer += stats[s];   }   return answer; }  console.log(\"2,2,2,3,4,5,6 : \", solution([2,2,2,3,4,5,6 ]))     괜히 쓸데없이 oppositeGroupA 같은 형식으로 구하려고했다. 단순하게 maxEl + NumberS === 7 으로 했으면 더 좋았을텐데…  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Naver-Hackday-Test-1/",
        "teaser":null},{
        "title": "[CodingTest] 숫자값 인코딩 조합구하기",
        "excerpt":"You are given an M by N matrix consisting of booleans that represents a board. Each True boolean represents a wall. Each False boolean represents a tile you can walk on.   Given this matrix, a start coordinate, and an end coordinate, return the minimum number of steps required to reach the end coordinate from the start. If there is no possible path, then return null. You can move up, left, down, and right. You cannot move through walls. You cannot wrap around the edges of the board.   For example, given the following board:   [[f, f, f, f], [t, t, f, t], [f, f, f, f], [f, f, f, f]] and start = (3, 0) (bottom left) and end = (0, 0) (top left), the minimum number of steps required to reach the end is 7, since we would need to go through (1, 2) because there is a wall everywhere else on the second row.   ","categories": ["CodingTest"],
        "tags": ["Javascript","DailyProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-5/",
        "teaser":null},{
        "title": "[DataType] 그래프 구조",
        "excerpt":"그래프      참고 자료 :            GeeksForGeeks - Implementation graph javascript           class Graph {   constructor(noOfVertices) {     this.noOfVertices = noOfVertices // the numbers of vertices. 인접한 버텍스들을 저장하기 위함.     this.AdjList = new Map() // 인접 리스트   }    addVertex(v) { // v를 AdjList의 키로 추가하고, 인접 리스트를  null array 로 초기화     this.AdjList.set(v, [])   }    addEdge(src, dest) { // src와 dest간에 에지 생성     this.AdjList.get(src).push(dest)     this.AdjList.get(dest).push(src)   }    printGraph() {     let get_keys = this.AdjList.keys()     for(let i of get_keys) {       let get_values = this.AdjList.get(i)       let conc = ''        for(let j of get_values) {         conc += j + \" \"       }        console.log(i + \" -&gt; \" + conc)     }   }       bfs(startingNode) { // BFS(Breadth First Search) 너비 우선 탐색     let visited = Array(this.noOfVertices.length).fill(false);     let q = new Queue()   } }  let g = new Graph(6);  let vertices = [ 'A', 'B', 'C', 'D', 'E', 'F' ]    // adding vertices  for (let i = 0; i &lt; vertices.length; i++) {      g.addVertex(vertices[i]) }     // adding edges  g.addEdge('A', 'B') g.addEdge('A', 'D') g.addEdge('A', 'E') g.addEdge('B', 'C') g.addEdge('D', 'E') g.addEdge('E', 'F') g.addEdge('E', 'C') g.addEdge('C', 'F')    // prints all vertex and  // its adjacency list  // A -&gt; B D E  // B -&gt; A C  // C -&gt; B E F  // D -&gt; A E  // E -&gt; A D F C  // F -&gt; E C  g.printGraph();    BFS(Breadth First Search) 너비 우선 탐색     DFS(Depth First Search) 깊이 우선 탐색    ","categories": ["Data Type"],
        "tags": ["Graph"],
        "url": "https://seunghyum.github.io/data%20type/Graph-With-Javascript/",
        "teaser":null},{
        "title": "[DataType] 트리 구조",
        "excerpt":"트리      트리 구조란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조이다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다. – 위키백과       Binary Search Tree      루트노드를 기준으로 작은 값은 왼쪽노드, 큰값은 오른쪽 노드로 설정하는 방식    코드      참고 :            HackerRank - with Java       기본기를 쌓는 정아마추어 코딩블로그 - ES6 이진 탐색 트리 구현하기, 어떻게 특정 값을 빠르게 찾을 수 있을까? (Binary Search Tree, BST)           class Node {   constructor(data, left, right) {     this.data = data     this.left = left     this.right = right   }    insert(value) {     if(value &lt;= this.data) {       if(this.left == null) {         this.left = new Node(value)       } else {         this.left.insert(value)       }     } else {       if (this.right == null) {         this.right = new Node(value)       } else {         this.right.insert(value)       }     }   }    contains(value) {     if(value == this.data) {       return true     } else if (value &lt; this.data) {       if( this.left == null) {         return false       } else {         return this.left.contains(value)       }     } else {       if(this.right == null) {         return false       } else {         return this.right.contains(value)       }     }   }    printInOrder() {     if(this.left != null) {       this.left.printInOrder();     }     console.log(this.data)     if(this.right != null) {       this.right.printInOrder();     }   }    printPostOrder() {     if(this.right != null) {       this.right.printPostOrder();     }     console.log(this.data)     if(this.left != null) {       this.left.printPostOrder();     }   }    printPreOrder() {     console.log(this.data)     if(this.left != null) {       this.left.printPreOrder();     }     if(this.right != null) {       this.right.printPreOrder();     }   } }  const tree = new Node(); tree.insert(10) tree.insert(20) tree.insert(7) tree.insert(3) tree.insert(6) tree.insert(13) tree.insert(16) tree.insert(1) tree.insert(19) console.log('=======Start In Order======') tree.printInOrder() console.log('=======End======') console.log('=======Start Pre Order======') tree.printPreOrder() console.log('=======End======') console.log('=======Start Post Order======') tree.printPostOrder() console.log('=======End======')   트리를 이용한 문제 예시      행렬(numArray)과 그 행렬의 개수(N)이 주어질때            행렬을 순서대로 +, - 등식으로 조합하여 결과값이 0이상 ~ 20이하로 값이 유지되고,       최종 값 역시 0이상 ~ 20이하로 값이 되도록하는       부등식 조합의 갯수를 구하시오.           // const N = 11, inputNumbers= [8,3,2,4,8,7,2,4,0,8,8]; // 10 // const N = 4, inputNumbers= [8,3,10,10]; const N = 9, inputNumbers = [3,6,9,7,2,1,2,5,3] // 3   let answer = 0; class Node {   constructor(data, count, allProcess, left, right) {     this.data = data     this.left = left     this.right = right     this.isLeftStop = false // this.data가  음수일 경우 더이상 진행하지 않기 위해     this.isRightStop = false // this.data가  20초과일 경우 더이상 진행하지 않기 위해     this.count = count     this.allProcess = allProcess   }    insert(value, c) {     if(this.data == undefined) {       this.data = value       this.count = c       this.allProcess = 3       return      }      if(this.isLeftStop == false) {       if(this.left == undefined) {           if(this.data - value &gt;= 0) {           this.left = new Node(this.data-value, c, this.allProcess + \" - \" + value)         } else {           this.isLeftStop = true         }       } else {         this.left.insert(value, c)       }       }     if(this.isRightStop == false) {       if(this.right == undefined) {         if(this.data + value &lt;= 20) {           this.right = new Node(this.data+value, c, this.allProcess + \" + \" + value)         } else {           this.isRightStop = true         }       } else {         this.right.insert(value, c)       }     }   }    traverse() {     if(this.left != undefined) {       this.left.traverse()     }      if(this.right != undefined) {       this.right.traverse()     }      if(this.count == N) {       answer++       console.log(\"this.allProcess : \", this.allProcess + \" = \" + this.data)     }   } }  const tree = new Node() for(let i=0;i&lt;N;i++) {   tree.insert(inputNumbers[i], i+1) } tree.traverse() console.log(\"answer : \", answer)  ","categories": ["Data Type"],
        "tags": ["Tree"],
        "url": "https://seunghyum.github.io/data%20type/Tree-With-Javascript/",
        "teaser":null},{
        "title": "[CodingTest] 벽안에 고인 빗물의 양",
        "excerpt":"문제   주어지는 행렬 arr(ex - [3,0,1,3,0,5])값의 인자들을 벽이라고 했을때 비가와서 물이 고이는 부분의 양을 구하여라.      답 : 8   내가 생각한 풀이      풀어본 시간 : 1시간   중간까지 밖에 못함. 접근방법이 복잡해져서 방향을 잘못잡음.            위로 꺾은 선들을 찾아서 각 구간마다 물이 고일수있는 max값을 찾고       해당 구간에서 max - arr[i] 값들의 합을 구하려고 했음           function solution(arr) {     let upperPoints = {0: arr[0]} // {index: value, ...}     for(let i=0;i&gt;arr.length;i++) {         if(arr[i-1] &lt; arr[i]) if(arr[i+1] == undefined) upperPoints[i] = arr[i]         else if(arr[i] &gt; arr[i+1]) upperPoints[i] = arr[i]     }      let filteredPoints = {0: arr[0]}, // {index: value, ...}         startPoint = [0, arr[0]]     for((p,i) of upperPoints) {         if(&amp;&amp; startPoint &gt;= upperPoints[i] &amp;&amp; i != 0 ) {             filteredPoints[i] = upperPoints[i];         }     }      // 중단함. }    정답풀이법      아이디어            왼쪽과 오른쪽을 각각 돌며 각 index마다의 물이 고일 수 있는 max값 찾음.       왼쪽 / 오른쪽에서 찾은 max값들 중 min 값으로 [min - 해당 index] 값을 구해서 total로 더함.           // 시간복잡도 O(n) 공간복잡도 O(n) function solution(arr) {     let left_maxes = [],          right_maxes = [],         current_left_max = 0,          current_right_max = 0,          total = 0;      for(let i=0; arr.length &gt; i; i++) {         current_left_max = Math.max(current_left_max, arr[i]);         left_maxes[i] = current_left_max;     }          for(let i=arr.length-1; 0 &lt;= i; i--) {         current_right_max = Math.max(current_right_max, arr[i]);         right_maxes[i] = current_right_max;     }      for(let i=0; arr.length &gt; i; i++) {         total += Math.min(left_maxes[i], right_maxes[i]) - arr[i];     }     return total; }   업그레이드된 정답풀이법      목적            공간 복잡도를 O(1)로 만들기위해 left_maxes, right_maxes를 없앰.           아이디어            가장 큰 수를 기점으로 오른쪽 / 왼쪽 나눔.           단점            울퉁불퉁한 모양이면 답이 제대로 나오지만 계단형태의 그래프일 경우 답이 이상하게 나옴.       arr = [1,2,3,4,5] 또는 [5,4,3,2,1]의 경우 답이 -3 나옴.       arr = [5,2,6,1,8,9,9,7] 에 해당하는 답안이 이상함.       arr = [3,0,1,3,0,5] 에만 잘 되는 답임.           // 시간복잡도 O(n) 공간복잡도 O(1) function solution(arr) {     if (arr.length == 0) return 0      let total = 0,         max_i = arr.indexOf(Math.max(...arr)),         left_max = arr[0],         right_max = arr[arr.length-1];      for (let i=1; max_i &gt; i; i++) {         total += left_max - arr[i];         left_max = Math.max(left_max, arr[i]);     }      for (let i=arr.length-2; max_i&lt;i; i--) {         total += right_max - arr[i];         right_max = Math.max(right_max, arr[i]);     }      return total; }  ","categories": ["CodingTest"],
        "tags": ["DailyProgramming","Javascript","BinarySearch","Set"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming/",
        "teaser":null},{
        "title": "[Algorithm] 유클리드 호제법(최대공약수 구하기) 공부",
        "excerpt":"정의      유클리드 호제법(- 互除法, Euclidean Algorithm)은 2개의 자연수 또는 정식(整式)의 최대공약수(Greatest Common Divisor)를 구하는 알고리즘의 하나이다.     호제법이란 말은 두 수가 서로(互) 상대방 수를 나누어(除)서 결국 원하는 수를 얻는 알고리즘을 나타낸다.     2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a&gt;b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.   이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고, 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.      이는 명시적으로 기술된 가장 오래된 알고리즘으로서도 알려져 있으며, 기원전 300년경에 쓰인 유클리드의 《원론》 제7권, 명제 1부터 3까지에 해당한다.      - 위키백과, 우리 모두의 백과사전.           설명   글설명      칸아카데미 참고   270과 192의 최대공약수 - GCD(270,192)          GCD(270,192) - 270과 192의 최대공약수 찾기            A=270, B=192       A ≠ 0       B ≠ 0           270 = 192 * 1 +78         GCD(270,192)=GCD(192,78) - 이기 때문에 192와 78의 최대공약수 찾기            A=192, B=78       A ≠0       B ≠0           192 = 78 * 2 + 36          GCD(192,78)=GCD(78,36) - 이기 때문에 78과 36의 최대공약수 찾기            A=78, B=36       A ≠0       B ≠0           78 = 36 * 2 + 6          GCD(78,36)=GCD(36,6) - 이기 때문에 36과 6의 최대공약수 찾기            A=36, B=6       A ≠0       B ≠0  36 = 6 * 6 + 0              GCD(36,6)=GCD(6,0) - 이기 때문에 6과 0의 최대공약수 찾기            A=6, B=0       A ≠0       B =0, GCD(6,0)=6              지금까지의 과정 :   GCD(270,192) = GCD(192,78) = GCD(78,36) = GCD(36,6) = GCD(6,0) = 6   GCD(270,192) = 6    그림설명      106와 16의 최대공약수 구하기 - GCD(106,16)           관련 코드   파이썬 코드   # 방법1 def gcd(m,n): # gcd == \"Greatest Common Divisor\" \tif m &lt; n: \t\tm, n = n, m \tif n == 0: \t\treturn m     if m % n == 0: \t\treturn n \telse: \t\treturn gcd(n, m%n)   # 방법2 def gcd(m,n):     while n != 0:        t = m%n        (m,n) = (n,t)     return abs(m)  # 방법3 def gcd(m,n):     while n! = 0: \t    if m &lt; n: \t\t    m, n = n, m \t    if n == 0: \t\t    return m \t    if m % n == 0: \t\t    return n    자바코드    public static int gcd(int p, int q)  { \tif (q == 0) return p; \treturn gcd(q, p%q);  }   자바스크립트코드      freeCodeCamp 참고   Javascript Code to Perform GCD   function gcd(a, b) { // 단, a가 b보다 커야함.   var R;   while ((a % b) &gt; 0)  {     R = a % b;     a = b;     b = R;   }   return b; }   Javascript Code to Perform GCD using Recursion   function gcd(a, b) { // 단, a가 b보다 커야함.   if (b == 0)     return a;   else     return gcd(b, (a % b)); }  function gcd(a,b) {return b ? gcd(b,a%b) : Math.abs(a)}   최소공배수(LCM: Least Common Multiple)      두 수(a,b) 중 어느 한수가 다른 한수의 약수가 아니면   최소공배수 = 최대공배수 * a * b    let LCM = a*b/GCD   두 수(n,m)의 최소공배수(LCM), 최대공약수(GCD) 구하기   function gcd(a,b) {return b ? gcd(b,a%b) : Math.abs(a)}  function solution(n, m) {    let a = n &gt; m ? n : m   let b = n &lt; m ? n : m   let k = gcd(a,b)    return [k, a*b/k] })  ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "https://seunghyum.github.io/algorithm/Euclidean-algorithm/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 4번 무지의 먹방 라이브 문제 with Javascript",
        "excerpt":"무지의 먹방 라이브      문제 바로가기 링크   카카오의 설명 블로그     나의 답안   function solution(food_times, k) {     if(food_times.length &gt; k) return k+1      const val = k / food_times.length,           rest = k % food_times.length,           timesSum = food_times.reduce((a, b) =&gt; a + b);          if(timesSum &lt;= k) return -1;          let count = 0;     for(let i=0;timesSum&gt;i;i++) {         const idx = i%food_times.length         if(food_times[idx] &gt; 0) {             food_times[idx]--             count++;             if(count == k) return (food_times.length &lt; idx+2 ? idx+2 - food_times.length : idx+2);         }     } }   결과      접근방식 및 아쉬웠던 점.   좋은 참고 사이트 : 참고사이트 Brute Force 문제였다. Object Array로 풀수있는 방법 중 좋은 방식을 생각하지 못했다. 루프를 진행하며 제외할수 있는 값을 계속 고려해서 루프를 돌았다. 그래서 불필요한 로직이 생겨버렸다.      내 정답들의 풀이 골격은 모두 다 해보는 Brute Force 알고리즘이다. 하지만 이렇게 하면 효율성 점수를 얻을 수 없다.      food_times 배열을 값과 인덱스로 Object Array을 만들고   각 줄마다 값이 있는 것들만 측정해서 k값을 지워나가고   k값이 0보다 클때 -1을 진행한다고 k=0이면 다음 요소로 넘어간다.     최고의 파이썬 답안   def solution(food_times, k):     if sum(food_times) &lt;= k: return -1     if len(food_times) &gt; k: return k+1ㅇ     n = len(food_times)     for i in range(n):         food_times[i] = [food_times[i],i+1]     ft = sorted(food_times,key=lambda x:x[0]) # 내림차순 정렬     i,r=0,0     while True:         if k - (n-i)*(ft[i][0]-r) &lt; 0:             break         else:             k -= (n-i)*(ft[i][0]-r)             r += (ft[i][0]-r)             i += 1     ft = sorted(ft[i:n], key = lambda x: x[1])     return ft[k%len(ft)][1]   결과      주요 로직 설명      food_times를 내림차순으로 정렬하여 가장 먼저 다 먹을 음식들 기준으로 정렬한다. =&gt; ft   ft를 순회하며(i += 1) 해당 시간만큼 남은 시간을 k(정전된시간)에 지속적으로 뺴준다. =&gt; k -= (n-i)*(ft[i][0]-r)   r에는 축적되는 시간을 계속 저장해둔다. =&gt; r += (ft[i][0]-r)        파이썬 답안을 보고 수정한 자바스크립트 답안   function solution(food_times, k) {     if(food_times.length &gt; k) return k+1;     if( food_times.reduce((a, b) =&gt; a + b) &lt;= k ) return -1;      const n = food_times.length;      for(let i=0;n&gt;i;i++) {         food_times[i] = [food_times[i],i+1];     }     let ft = food_times.sort((a, b) =&gt; a[0] - b[0]), // 내림차순 정렬         i = 0,         r = 0;     while(true) {         if( k-(n-i)*(ft[i][0]-r) &lt; 0 ) break;         else {             k -= (n-i)*(ft[i][0]-r);             r += ft[i][0]-r;             i += 1;         }     }     ft = food_times.slice(i,n).sort((a, b) =&gt; a[1] - b[1]);     return ft[k%ft.length][1]; }   결과        좋은 자바스크립트 답안   function solution(food_times, k) {   let copy = [],       total = 0;   for (let i = 0; i &lt; food_times.length; i++) {     total += food_times[i];     copy[i] = { val: food_times[i], index: i + 1 };   }    if (total &lt;= k) return -1;    copy.sort((a, b) =&gt; {     if (a.val === b.val) a.index - b.index;     return a.val - b.val;   });    let sum = 0;   let sub = 0;    for (let i = 0; i &lt; copy.length; i++) {     sub = (copy[i].val - sum) * (copy.length - i);     if (k - sub &gt;= 0) {       sum += copy[i].val - sum;       k -= sub;     } else {       let temp = Math.floor(k / (copy.length - i));       k -= temp * (copy.length - i);       sum += temp;       break;     }   }    copy = copy.filter(item =&gt; item.val - sum &gt; 0);   copy.sort((a, b) =&gt; a.index - b.index;);    return copy[k].index; }  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/KaKao-Eat-Live/",
        "teaser":null},{
        "title": "[Algorithm] 순환(Recursion) 알고리즘 공부",
        "excerpt":"참고      영리한 프로그래밍을 위한 알고리즘 강좌   recursion versus iteration - Stack Overflow   특징      모든 순환함수는 반복문(iteration)으로 변경가능. 그 역도 성립.   장점      순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함.   반복문에 비해 코드가 짧아짐.   단점      함수호출에 따른 오버해드가 있음. 그래서 반복문 보다 일반적으로 느림.            ex) 스택에 함수 / 매개변수 저장과 그에 따른 메모리 할당.           종료처리에 오류가 있으면 시스템이 무한루프에 빠지게될수도 있음.   순환 알고리즘의 설계     적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야함. -&gt; 무한루프 빠지지 않게.   모든 case는 결국 base case로 수렴해야 함.   재귀적 호출시 반드시 필요한 매개변수를 명시적 매개변수로 바꾸어라. 그렇지 않으면 재귀적 호출시 적절한 매개변수를 호출할 수 없을수도 있음.   예시   문자열의 프린트   public static void printChars(String str) {     if(str.lenfgth()==0)         return;     else {         System.out.print(str.charAt(0));         printChars(str.substring(1));     } }   문자열을 뒤집어서 프린트   public static void printCharsReverse(String str) {     if(str.lenfgth()==0)         return;     else {         printChars(str.substring(1)); // 위의 '문자열의 프린트' 예시코드에서 바로 아래줄의 코드와 순서만 바뀌었는데 reverse가 됨.         System.out.print(str.charAt(0));     } }   정수 input값을 2진수로 변환하여 출력  public void printInBinary(int n) {     if(n&lt;2)         System.out.print(n);     else {         printInBinary(n/2);          System.out.print(n%2);     } }  ","categories": ["Algorithm"],
        "tags": ["Recursion","Java"],
        "url": "https://seunghyum.github.io/algorithm/Recursion/",
        "teaser":null},{
        "title": "[GoogleAnalytics] 자기 자신의 활동기록 제외 (prevent recording myself)",
        "excerpt":"참고     5 ways to exclude your own visits from Google Analytics   How to exclude your own [dynamic] ip from Google Analytics   괜찮은 방법들     서버사이드나 백엔드 매서드            설명 : Dynamic DNS를 사용하여 IP를 제외. 과정이 복잡함. 회사에서 쓰기 적합.       장점 : 시스템으로 돌아감.       단점                    복잡하다.           캐시를 사용설정 해놓으면 무의미. DDNS 설정을 한 이후에도 설정전에 사이트에 접속한적이 있다면 혹시라도 남아있을 캐시는 제거하는 것이 필요.                           Google Analytics 필터로 Public IP 제외            과정 : GA(Google Analytics) 대쉬보드 -&gt; 관리 클릭 -&gt; 보기의 필터 클릭 -&gt; 필터 추가       장점 : 고정 IP만 쓰는 장치 제외에 적합.       단점 : 유동 IP이면 무의미. (핸드폰, 노트북 등 네트워크 전용선을 쓰지 않고 옮겨다니며 와이파이를 쓰는 경우)           브라우저 확장프로그램            설명 : 확장프로그램을 작동시켜 IP를 제외시킴.       장점 : 가장 간단.       단점 : 모바일, 테블릿에서 쓰지 못할수 있음.       추천 프로그램                    Google 웹로그 분석 차단 추가 기능(Google 제공)           Block Yourself from Analytics                          ","categories": ["GoogleAnalytics"],
        "tags": ["GoogleAnalytics"],
        "url": "https://seunghyum.github.io/googleanalytics/Google-Analytics-prevent-self/",
        "teaser":null},{
        "title": "[ELK] 단쿠키 - ElasticSearch, Logstash, Kibana 설정하기",
        "excerpt":"적용 배경   단쿠키(단국대학교 커뮤니티 웹서비스 이름) 작업을 하다가 검색시 mongoDB에서 게시글의 title과 content를 text searching으로 검색결과를 산출하려헀지만 많은 비용이 발생하였다.   Write기능에 특화된 MongoDB에서 근 10년 간의 데이터들을 Read하는 것이 서버에 부담이 되었다. 또한 검색을 분석하여 유저들의 수요를 분석하고 보다 나은 포털 UI를 갖추기 위해 Elastic Search를 도입하기로 했다.   그래서 이번기회에 ELK 스펙을 공부하고 적용하여 검색 데이터를 효율적으로 산출하고 관리할 수 있게 만들기로 했다.   기술 스팩   지금까지의 기술스펙을 그림으로 표현하면 아래와 같다.      진행과정  AWS EC2 서버에 docker-elk레포의 내용대로 진행한다.     Docker와 docker-compose를 설치   Repo 클론 후 docker-compose   docker-compose.yml의 내용을 서버에 맞게 수정한다.   참고      인프런 ELK 스펙   깃헙 repo - docker-elk  ","categories": ["ELK"],
        "tags": ["ELK","단쿠키","docker","docker-compose"],
        "url": "https://seunghyum.github.io/elk/ELK_Stack/",
        "teaser":null},{
        "title": "[CodingTest] 2020 카카오 신입 공채 1차 - 2번 괄호 문자열 정제 문제 with Javascript",
        "excerpt":"  느낀점   재귀함수 문제. 지문을 그대로 코드로 변경하면 풀 수 있는 문제였음. 재귀함수에서 break를 제대로 안해서 시간이 지체됨.   내가 작성한 답변   function solution(s) {   return filterText(s) }  function filterText(s) {   if(s===\"\") return \"\";   let stats = {\"(\":0, \")\":0},       result = \"\";   for(let i=0;i&lt;s.length;i++){     if(s[i] === \"(\") stats[\"(\"]++;     else stats[\")\"]++;      if(stats[\"(\"] === stats[\")\"]) {       let u = s.substring(0,i+1),           v = s.substring(i+1,s.length) || \"\";       if(isRight(u)) result += u + filterText(v)       else {         if(v !== \"\") result += \"(\" +  filterText(v) + \")\";         result += filterWrongString(u);       }       break;     }   }   return result }    function isRight(u) {   if(u[0] == \")\") return false;   let stats = {\"(\":0, \")\":0};   for(let i=0;i&lt;u.length;i++){     if(u[i] === \"(\") stats[\"(\"]++;     else stats[\")\"]++;   }   if(stats[\"(\"] &lt; stats[\")\"]) return false;   return true; }  function filterWrongString(u) {   let result = \"\"   if(u.length !== 2) {     for(let i=0;i&lt;(u.length-2)/2;i++) {       result = \"(\".repeat((u.length-2)/2) + \")\".repeat((u.length-2)/2)     }   } else result = \"()\"   return result; }  console.log('solution(\"\") -&gt; result : ', solution(\"\"), \" Must be ''. It is \", solution(\"\") == \"\" ? \"Right\" : \"Wrong\") console.log(\"------------------\") console.log('solution(\"(()())()\") -&gt; result : ', solution(\"(()())()\"), \" Must be (()())(). It is \", solution(\"(()())()\") == \"(()())()\" ? \"Right\" : \"Wrong\") console.log(\"------------------\") console.log('solution(\")(\") -&gt; result : ', solution(\")(\"), \" Must be (). It is \", solution(\")(\") == \"()\" ? \"Right\" : \"Wrong\") console.log(\"------------------\") console.log('solution(\"()))((()\") -&gt; result : ', solution(\"()))((()\"), \" Must be ()(())(). It is \", solution(\"()))((()\") == \"()(())()\" ? \"Right\" : \"Wrong\")   ","categories": ["CodingTest"],
        "tags": ["Javascript","Recursion"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-Text-Bracket/",
        "teaser":null},{
        "title": "[CodingTest] 2020 카카오 신입 공채 1차 - 4번 정규표현식 문제 with Javascript",
        "excerpt":"  내가 작성한 답변   function solution(words, queries) {   let result = [];   for(let i=0;i&lt;queries.length;i++) {     let reg,         q = queries[i],         s = q.replace(/\\?/g,\"\");      result[i] = 0;      reg = new RegExp(`${s}`, \"g\");          for(let j=0;j&lt;words.length;j++) {       let w = words[j];        if(w.length !== q.length) continue;       if(w.match(reg)) {         result[i]+=1;       }     }   }   return result }  let w = [\"frodo\", \"front\", \"frost\", \"frozen\", \"frame\", \"kakao\"],     q = [\"fro??\", \"????o\", \"fr???\", \"fro???\", \"pro?\", \"?????\"];      console.log(` w = [\"frodo\", \"front\", \"frost\", \"frozen\", \"frame\", \"kakao\"], \\n q = [\"fro??\", \"????o\", \"fr???\", \"fro???\", \"pro?\", \"?????\"] \\n solution(w, q) -&gt; result : ${solution(w, q)} \\n Must be [ 3, 4, 4, 1, 0, 5 ]. \\n My answer is ${String(solution(w, q)) == String([ 3, 4, 4, 1, 0, 5 ]) ? \"Right\" : \"Wrong\"} `)  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-RegExp-Text/",
        "teaser":null},{
        "title": "[CodingTest] 2020 네이버 공채 코드테스트 문제 with Javascript",
        "excerpt":"2번  function solution(drum) {   let result = 0;   let currentPosition = {     x: 0,     y: 0   }    for (let x = 0; x &lt; drum[0].length; x++) {     currentPosition.x = x;     currentPosition.y = 0;     let starCount = 0;     if (currentPosition.x == 1 &amp;&amp; currentPosition.y == 1) return     loop:       while (true) {         if (drum[currentPosition.y][currentPosition.x] == \"#\") currentPosition.y++;         else if (drum[currentPosition.y][currentPosition.x] == \"&gt;\") currentPosition.x++;         else if (drum[currentPosition.y][currentPosition.x] == \"&lt;\") currentPosition.x--;         else if (drum[currentPosition.y][currentPosition.x] == \"*\") {           starCount++;           if (starCount == 2) break loop;           else currentPosition.y++;         }         if (currentPosition.y === drum.length) {           result++;           break loop;         }       }   }   return result; }   3번 - 아는동생이 푼것   def solution(data):     answer = []     daegi = []     time = -1     new_list = []     size = len(data)          for i in data:         new_data = {}         strings = ['N', 'time', 'pages']         for j in range(3):             new_data[strings[j]] = i[j]         new_list.append(new_data)              success = []     empty_one = {'N' : -1, 'time' : -1,'pages' : -1}     present_one = empty_one          while(1):         time += 1         if(len(new_list) &gt; 0):             first = new_list[0]             # 대기열에 추가             if(time == first['time']):                 daegi.append(first)                 new_list.pop(0)         # 페이지순 정렬         if(len(daegi) &gt; 0):             daegi = sorted(daegi, key=lambda k: k['pages'])             if(present_one['N'] == -1):                 present_one = daegi[0]                 present_one['end_time'] = time + present_one['pages'] -1                 daegi.pop(0)                          if(present_one['N'] == -1):             continue         elif(present_one['end_time'] == time):              success.append(present_one['N'])             present_one = empty_one         if(len(success) == size):             break     answer = success     return answer   3번 공부하고 다시 작성한 답변  function solution(data) {   let time = 0,       wait = [],       answer = [],       new_data = [];    data.map(d =&gt; {     new_data.push({N:d[0], reqTime: d[1], page: d[2]})   })    while(true){     // 대기열과 기존 데이터 정리     loop2:       while(true) {         for(let i=0;i&lt;new_data.length;i++) {           if(new_data[0].reqTime &lt;= time) {             wait.push(new_data[0])             new_data.shift();           }            else time++;            if(!new_data[i+1]) break loop2; // 정렬할 데이터가 1개밖에 없을 시           if(new_data[i].reqTime &gt; time) break loop2;         }       }            // 대기열 정렬     if(wait.length &gt;= 2) wait.sort((a,b) =&gt; a.page - b.page)          if(wait[0]) {       time += wait[0].page       answer.push(wait[0].N)       wait.shift();     }          if(new_data.length == 0 &amp;&amp; wait.length==1) {       answer.push(wait[0].N)       break;     }   }    // console.log(\"final answer : \", answer)   return answer }  console.log(` input : [[1, 0, 5],[2, 2, 2],[3, 3, 1],[4, 4, 1],[5, 10, 2]] \\n Result Must be [1,3,4,2,5]  My answer is [${solution([[1, 0, 5],[2, 2, 2],[3, 3, 1],[4, 4, 1],[5, 10, 2]])}] `)  console.log(` input : [[1, 0, 5],[2, 2, 2],[3, 3, 1],[4, 4, 1],[5, 10, 2]] \\n Result Must be [1,3,2,4,5]  My answer is [${solution([[1, 0, 5],[2, 2, 2],[3, 3, 1],[4, 4, 1],[5, 10, 2]])}] `)  console.log(` input : [[1, 2, 10], [2, 5, 8], [3, 6, 9], [4, 20, 6], [5, 25, 5]] \\n Result Must be [1,2,4,5,3]  My answer is [${solution([[1, 2, 10], [2, 5, 8], [3, 6, 9], [4, 20, 6], [5, 25, 5]])}] `)  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Naver-Offical-2020/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트",
        "excerpt":"  2번 - Not Solved   마지막까지 적은 답   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   const n = data.split(\"\\n\"),     k = Number(n[1]),     b = n[0],     tmp = b.split(\" \"),     numbers = tmp.sort((a, b) =&gt; a - b),     stats = {};   for (let i = 0; i &lt; numbers.length; i++) {     if (stats[numbers[i]]) stats[numbers[i]]++;     else stats[numbers[i]] = 0   }    for (let i = 0; i &lt; numbers.length; i++) {     let v = 0;     loop:     for (let j = 1; j &lt; numbers.length - i; j++) {       if (i == 0 &amp;&amp; numbers[0] == '0') continue;       k = k - factorial(numbers.length - j)       if (k) &lt; 0) break loop;       else v++;     }     stats[i] = v   }    function factorial(n) {     return n ? n * factorial(n - 1) : 1;   }    // console.log(a + b); });   느낀점   순열문제라는 것은 알았지만 풀지 못함. 순열 조합 관련 코드를 인터넷에서 찾아서 바로 적용했다면 풀 수 있었음. 겁먹고 멘탈이 나간게 폐인.   풀이법        3번 - Not Solved   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   const tmp = data.split(/\\n/);   const n = Number(tmp[0]);   tmp.shift()   const timeline = tmp.map(t =&gt; t.split(\" \").map(e =&gt; Number(e)))   console.log(\"n : \", n);   console.log(\"timeline : \", timeline);   let endTime = 0;   let answer = 0;    for (let i = 0; i &lt; timeline.length; i++) {     let k = 0;     for (let j = i + 1; j &lt; timeline.length; j++) {       if (timeline[i][1] &gt; timeline[j][0] &amp;&amp; timeline[i][0])     }   }    // for(let i=0;i&lt;timeline.length;i++){   //     endTime = timeline[i][1] &gt; endTime ? timeline[i][1] : endTime;   // }    // for(let i=0;i&lt;endTime;i++) {   //     for(let i=0;i&lt;timeline.length;i++){   //         endTime = timeline[i][1] &gt; endTime ? timeline[i][1] : endTime;   //     }   // } });   6번 - Not Solved    ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트 1번",
        "excerpt":"  1번 : Solved   제출한 코드   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   // 인풋 데이터 정제   const n = data.split(\" \"),     tmp = n[1].split(/\\n/),     mesages = Number(n[0]),     consumers = Number(tmp[0]);   tmp.shift()   const times = tmp;    let result = 0,     compare = [];      // 로직 수행을 위한 데이터 정제   for (let i = 0; i &lt; consumers; i++) {     let tmp = {}     tmp['index'] = i     tmp['time'] = 0     compare.push(tmp)   }    // 가장 낮은 time 값을 sort로 찾고 대기열의 숫자 추가    // A번   for (let i = 0; i &lt; times.length; i++) {     compare.sort((a, b) =&gt; a.time - b.time); // m * nlogn     compare[0].time += Number(times[i]);   }    // 최대값 추출   compare.sort((a, b) =&gt; b.time - a.time);  //  nlogn   console.log(String(compare[0].time)) });   느낀점   객체 배열(Obect Array)과 정렬(sort)로 푸려고함. 시간복잡도 O(nlogn) A번에서 좀 더 효율적인 알고리즘을 만들 수 없었을까. js 반복문 for, reduce, forEach, map, some, every 매서드들의 용도 다시 공부함.      for : array에 대한 반복이 아닌 횟수 반복을 적용하고자할 때 사용.   reduce : 깔대기에 물을 들이 붙는 것처럼 축적된 값(accumulator)를 반환. 비교할때, 축적된 값을 뽑을때 사용.   forEach : 함수를 순회함. index를 볼 수 있음. for문을 대체가능   map : 함수를 순회하며 인자를 다른 인자로 맵핑해서 새로운 array를 반환.   some : 배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트합니다.   every : 모든 요소들이 조건을 만족시키는지 확인.   수정한 답     // ...   // A번 수정   // 가장 낮은 time 값을 sort로 찾고 대기열의 숫자 추가   for (let i = 0; i &lt; times.length; i++) { // n     // compare.sort((a, b) =&gt; a.time - b.time);     // compare[0].time += Number(times[i]);     const target = compare.reduce((a,b) =&gt; a.time &gt; b.time ? b : a) // n*m     compare.forEach(e =&gt; {       if(target.index === e.index) e.time += Number(times[i])     }) // n*2m   }    // 최대값 추출   // compare.sort((a, b) =&gt; b.time - a.time);   // console.log(String(compare[0].time))   const answer = compare.reduce((a,b) =&gt; a.time &lt;b.time ? b : a)   console.log(String(answer.time)) })  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit-1/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트 4번",
        "excerpt":"  4번 - Solved   제출한 코드   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   const n = data.split(/\\n/);   const a = Number(n[0]),     b = n[1];   const sits = b.split(\" \");   let answer;    for (let i = 0; i &lt; sits.length; i++) {     if (sits[i] == \"1\") continue;     let right = 1,       left = 1;     loop:       for (let j = i; j &lt; sits.length; j++) {         if (!sits[j + 1] || sits[j + 1] == \"1\") break loop;         right++;         if (!sits[j - 1] || sits[j - 1] == \"1\") break loop;         left++;       }      let tmp = right &gt; left ? left : right;     if (!answer) answer = tmp;     else answer = answer &gt; tmp ? answer : tmp;   }   console.log(answer) });   내가 푼 방식   [1, 0, 1, 0, 0, 0, 1] 중 0인 값들만 선택적으로 골라 i-1, i+1인 곳을 찾아 통계를 매김.   다시 생각한 방식      1과 0이 이어지는 곳 중 0이 가장 많이 이어지는 곳들을 찾고   해당 구간의 중간을 찾아 좌우 거리를 측정 했다면 시간 복잡도를 더 줄일 수 있을 것 같음.   function solution(data) {   const n = data.split(/\\n/),         a = Number(n[0]),         b = n[1];   const sits = b.split(\" \");   let answer,       maxLength=0,       maxLengthStartIndex=0;    for (let i = 0; i &lt; sits.length; i++) {     if (sits[i] == \"1\") continue;     else {       let checkLength=0,           checkIndex=i;       loop:       for(let j=1;j&lt;sits.length-i;j++) {         if(sits[i+j]==\"1\") {           if(maxLength &lt; checkLength) {             i+=j // 계산한 값들은 건너뛰어서 측정             maxLength = checkLength             maxLengthStartIndex = checkIndex           }           break loop;         } else {           checkLength+=1         }       }     }   }   if(maxLength%2 == 0) answer = Math.floor(maxLength/2)+1   else answer = Math.floor(maxLength/2)   console.log(answer) } solution(`8 1 0 1 0 0 0 0 1`)  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit-4/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트 5번",
        "excerpt":"  5번 - Solved   제출한 코드   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   const n = data.split(/\\n/),     a = n[0],     b = n[1],     field = a.split(\" \").map(f =&gt; Number(f)),     position = b.split(\" \").map(f =&gt; Number(f));   if (position[0] &gt; field[0] || position[1] &gt; field[1]) console.log(\"fail\")   let answer = factorial(position[0] + position[1]) / (factorial(position[0]) * factorial(position[1]))    function factorial(n) {     return n ? n * factorial(n - 1) : 1;   }    console.log(answer + \"\\n\" + (position[0] + position[1])) });         소감   팩토리얼 공식을 구글에서 찾아 팩토리얼로 품. 순열, 조합 문제를 코드로 처음 풀어봐서 개념 정리하고 접근 방법을 생각하는데 시간이 많이 듦.  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit-5/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트 Preview",
        "excerpt":"  소감   총 6문제. 시험시간 3시간. 프로그래머스에서 진행   1,4,5만 풀음. 2,3,6은 못품.      내가 푼 방식            2번 : 순열       5번 : 조합       나머지는 다 반복문으로 품.           1,4는 쉬운편.   순열, 조합에 대한 경험이 있었으면 2,5번에서 시간을 아껴서 어려웠던 3,6번에 더 집중할 수 있었을 듯 싶다.   3번 : O(n2) 이외의 경우만 생각하다가 못품. 6번 : 시간이 모자라 못품.   궁금한점은 프로그래머스에서 풀이를 python으로 했을 때의 효율성 점수와 javascript나 C++로 했을 때의 효율성 점수를 다르게 측정하는지가 궁금.   Python은 내장 라이브러리로 순열 조합을 쉽게 가져다 쓸 수 있지만 js는 아님. 앞으로 Python으로 시험칠까 고민해봐야겠음.      문제별 풀이 및 수정한 답변   문제는 저작권상 가져오면 안되어서 없음. 작성한 글들은 더 좋은 답안을 발견하면 수정할 예정. 전부 Javascript로 풀었지만 공부하면서 Python도 가져옴.      1번   2번   3번   4번   5번   6번  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit-Preview/",
        "teaser":null},{
        "title": "[Algorithm] 순열(Permutation) & 조합(Combination) 공부",
        "excerpt":"   서로 다른 n개의 원소에서 r개를 중복없이 골라 순서에 상관있게 나열하는 것을 n개에서 r개를 택하는 순열이라고 한다    참고 : 조합과 순열 알고리즘, 파이썬으로 구현하기                 Python       파이썬의 경우 라이브러리가 있어서 바로 가져다 쓸 수 있다. 하지만 직접 구현한 코드를 볼 필요가 있다.  중간에 로직을 추가하여 결과값을 다 돌지 않고도 Loop를 도는 중간에 답을 찾을 수 있기 때문이다.  2020 라인 SW개발 DEVEL-UP 인턴십 2번 문제에서 경험함.       직접 구현한 Python 코드       아래 코드는 (조합과 순열 알고리즘, 파이썬으로 구현하기에서 퍼옴)   def permutation(arr, r):     arr = sorted(arr) # 순서대로 출력하기 위해 데이터 정렬     used = [0 for _ in range(len(arr))] # 각 자리수에 대한 사용여부 통계     # : [0 for _ in range(len(\"abcd\"))] =&gt; [0,0,0,0].      def generate(chosen, used):         if len(chosen) == r:             print(chosen)             return          for i in range(len(arr)):              if not used[i]:                 chosen.append(arr[i])                 used[i] = 1                 generate(chosen, used)                 used[i] = 0                 chosen.pop()     generate([], used)   &gt;&gt;&gt; permutation('ABCD', 2) # =&gt;  ['A', 'B'] #     ['A', 'C'] #     ['A', 'D'] #     ['B', 'A'] #     ['B', 'C'] #     ['B', 'D'] #     ['C', 'A'] #     ['C', 'B'] #     ['C', 'D'] #     ['D', 'A'] #     ['D', 'B'] #     ['D', 'C'] &gt;&gt;&gt; permutation([1, 2, 3, 4, 5], 3) # [1, 2, 3] # [1, 2, 4] # [1, 2, 5] # [1, 3, 2] # [1, 3, 4] # ... 중략         라이브러리를 사용한 Python 코드        참고 : 순열과 조합 라이브러리를 사용해보자 [Python]    from itertools import permutations # 순열 from itertools import combinations # 조합 from itertools import product # 중복허용 순열   순열 : 중복 허용 X.   from itertools import permutations per = permutations([\"빨\",\"주\",\"노\",\"초\"],2) print(list(per)) #=&gt; [('빨', '주'), ('빨', '노'), ('빨', '초'), ('주', '빨'), ('주', '노'), ('주', '초'), ('노', '빨'), ('노', '주'), ('노', '초'), ('초', '빨'), ('초', '주'), ('초', '노')] #순열 : 중복 허용o   product는 중복을 허용한 방법입니다. 이때 repeat으로 인자를 설정해야합니다!   from itertools import product per1 = product(([\"빨\",\"주\",\"노\",\"초\"]), repeat=2) print(list(per1)) #=&gt; [('빨', '빨'), ('빨', '주'), ('빨', '노'), ('빨', '초'), ('주', '빨'), ('주', '주'), ('주', '노'), ('주', '초'), ('노', '빨'), ('노', '주'), ('노', '노'), ('노', '초'), ('초', '빨'), ('초', '주'), ('초', '노'), ('초', '초')]   조합은 nCr로 표현하는데요~ n개중에 r개를 뽑는 수 입니다. 나열하는 경우가 없는 것에서 순열과 차이가 있죠?   조합 : 중복 허용x combinations는 중복을 허용하지 않습니다.    ```python from itertools import combinations print(list(combinations('빨주노초',2))) #=&gt; [('빨', '주'), ('빨', '노'), ('빨', '초'), ('주', '노'), ('주', '초'), ('노', '초')]   조합 : 중복 허용o combinations_with_replacement는 중복을 허용한 방법입니다.   from itertools import combinations_with_replacement print(list(combinations_with_replacement(\"빨주노초\",2))) #=&gt; [('빨', '빨'), ('빨', '주'), ('빨', '노'), ('빨', '초'), ('주', '주'), ('주', '노'), ('주', '초'), ('노', '노'), ('노', '초'), ('초', '초')]      Javascript         ","categories": ["Algorithm"],
        "tags": ["Permutation"],
        "url": "https://seunghyum.github.io/algorithm/Permutation/",
        "teaser":null},{
        "title": "Javascript Skills",
        "excerpt":"  각 반복문의 용도           for : array에 대한 반복이 아닌 횟수 반복을 적용하고자할 때 사용.   reduce : 깔대기에 물을 들이 붙는 것처럼 축적된 값(accumulator)를 반환. 비교할때, 축적된 값을 뽑을때 사용.   forEach : 함수를 순회함. index를 볼 수 있음. for문을 대체가능   map : 함수를 순회하며 인자를 다른 인자로 맵핑해서 새로운 array를 반환.   some : 배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트합니다.   every : 모든 요소들이 조건을 만족시키는지 확인.   for … of            반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복       [Symbol.iterator] 속성이 있는 모든 컬렉션 요소에 대해 이 방식으로 반복       각 개별 속성값에 대해 실행되는 문이 있는 사용자 정의 반복 후크를 호출하는 루프를 생성합니다.           for … in : 객체의 모든 non-Symbol, enumerable properties을 반복합니다.      Nested 반복문에서 제어   Nested 반복문에서 break나 continue 걸고 바깥반복문으로 넘어가는 방법 : label      label : 반복문(for문)안에서 사용가능.   // MDN 예제를 가져옴.  //// continue var i, j;  loop1: for (i = 0; i &lt; 3; i++) {      //첫번째 for문은 \"loop1\" 레이블을 붙였다.    loop2:    for (j = 0; j &lt; 3; j++) {   //두번째 for문은 \"loop2\" 레이블을 붙였다.       if (i === 1 &amp;&amp; j === 1) {          continue loop1;       }       console.log('i = ' + i + ', j = ' + j);    } }  // 출력 결과: //   \"i = 0, j = 0\" //   \"i = 0, j = 1\" //   \"i = 0, j = 2\" //   \"i = 1, j = 0\" //   \"i = 2, j = 0\" //   \"i = 2, j = 1\" //   \"i = 2, j = 2\" // 다음 두 경우를 어떻게 스킵하는지 주목 : \"i = 1, j = 1\", \"i = 1, j = 2\"  //// break for (let i = 0; i &lt; numbers.length; i++) {   loop:   for (let j = 1; j &lt; numbers.length - i; j++) {     if (k) &lt; 0) break loop;   } }          배열 중간에 요소 추가 및 삭제        Splice 매서드  : 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경   array.splice(start[, deleteCount[, item1[, item2[, ...]]]])   start      배열의 변경을 시작할 인덱스   배열의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정됩니다.   음수인 경우 배열의 끝에서부터 요소를 세어나갑니다(원점 -1, 즉 -n이면 요소 끝의 n번째 요소를 가리키며 array.length - n번째 인덱스와 같음).   값의 절대값이 배열의 길이 보다 큰 경우 0으로 설정됩니다.   deleteCount      Optional   배열에서 제거할 요소의 수입니다.   deleteCount를 생략하거나 값이 array.length - start보다 크면 start부터의 모든 요소를 제거합니다.   deleteCount가 0 이하라면 어떤 요소도 제거하지 않습니다. 이 때는 최소한 하나의 새로운 요소를 지정해야 합니다.   item1, item2, …      Optional   배열에 추가할 요소입니다. 아무 요소도 지정하지 않으면 splice()는 요소를 제거하기만 합니다.   예제   // # 하나도 제거하지 않고, 2번 인덱스에 \"drum\"과 \"guitar\" 추가섹션 var myFish = ['angel', 'clown', 'mandarin', 'sturgeon']; var removed = myFish.splice(2, 0, 'drum', 'guitar');  // myFish is [\"angel\", \"clown\", \"drum\", \"guitar\", \"mandarin\", \"sturgeon\"]  // removed is [], no elements removed   // # 3번 인덱스에서 한 개 요소 제거섹션 var myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon']; var removed = myFish.splice(3, 1);  // removed is [\"mandarin\"] // myFish is [\"angel\", \"clown\", \"drum\", \"sturgeon\"]   // # 2번 인덱스에서 한 개 요소 제거하고 \"trumpet\" 추가섹션 var myFish = ['angel', 'clown', 'drum', 'sturgeon']; var removed = myFish.splice(2, 1, 'trumpet');  // myFish is [\"angel\", \"clown\", \"trumpet\", \"sturgeon\"] // removed is [\"drum\"]  // # -2번 인덱스에서 한 개 요소 제거섹션 var myFish = ['angel', 'clown', 'mandarin', 'sturgeon']; var removed = myFish.splice(-2, 1);  // myFish is [\"angel\", \"clown\", \"sturgeon\"]  // removed is [\"mandarin\"]   fill 매서드   : 배열의 startIndex 부터 endIndex까지 정적으로 채우\u001c기      arr.fill(value[, start[, end]])       value   배열을 채울 값.   start Optional   시작 인덱스, 기본 값은 0.   end Optional   끝 인덱스, 기본 값은 this.length.  ","categories": ["Javascript"],
        "tags": ["Skills"],
        "url": "https://seunghyum.github.io/javascript/Javascript-Skills/",
        "teaser":null},{
        "title": "[CodingTest] 피보나치 수열",
        "excerpt":"문제 : 피보나치 수열  제 1항부터 입력한 자연수(N)까지의 피보나치 수열 항들의 합을 구하여라.      F0 = 0  F1 = 1z  Fn+2 = Fn+1 + Fn                   N       Fibonacci(N)       Answer                       0       0       0                 1       1       1                 2       1       2                 3       2       4                 4       3       7                 5       5       12                 6       8       20                 7       13       33                 8       21       54                 9       34       88                 10       55       143           내 답안 : 메모제이션 적용   // Run by Node.js ​ const readline = require(\"readline\"); const rl = readline.createInterface({   input: process.stdin,   output: process.stdout }); ​ ​ rl.on(\"line\", function(line) {   if(line==1) return console.log(1)   let memo = {0:0, 1:1, 2:1}      function fibonacci(n) {     if(n==0) return 0     if(!memo[n]) memo[n] = fibonacci(n-1) + fibonacci(n-2)     return memo[n]   } ​   function sum(obj) {     return Object.keys(obj).reduce((sum,key)=&gt;sum+obj[key]||0,0);   }   fibonacci(line)   console.log(sum(memo))   rl.close(); }).on(\"close\", function() {   process.exit(); });   더 좋은 방법   변수에 기억해두어서 공간 복잡도를 더 낮추는 방법.  피보나치 수열을 재귀법으로 작성하면 많은 노드들이 중복되어 호출된다.   예를 들어  Fibonacci(5)를 구한다고 했을 때, Fibonacci(3)은 두 번, Fibonacci(2)는 세 번이 호출된다.  이들이 호출될 때마다 다시 계산할 필요는 없다.   따라서 Fibonacci(N)를 캐시에 저장하고, 나중에 저장된 값을 사용하는 방식이 메모이제이션 방식이다.   // Run by Node.js ​ const readline = require(\"readline\"); const rl = readline.createInterface({   input: process.stdin,   output: process.stdout }); ​ ​ rl.on(\"line\", function(line) {   if(line==0) return console.log(0)   if(line==1) return console.log(1)   if(line==2) return console.log(2)   let memo = {0:0, 1:1, 2:1}, before, after, answer=0   for(let i=3;i&lt;=line;i++){     after += before     before = after     answer += after   } ​   rl.close(); }).on(\"close\", function() {   process.exit(); });    ","categories": ["CodingTest"],
        "tags": ["Javascript","Goorm"],
        "url": "https://seunghyum.github.io/codingtest/Fibonacci-Sequence/",
        "teaser":null},{
        "title": "Javascript 개념 정리",
        "excerpt":"알고리즘 공부를 하며 부족했던 개념을 다시 정리   함수 표현식의 장점     참고 : 캠틴 판교님 블로그 - 함수 표현식 vs 함수 선언식                     함수 선언식과 달리 호이스팅에 영향안받음.         클로져로 사용.         콜백으로 사용(다른 함수의 인자로 넘길수 있음)                  : AirBnb의 스타일가이드에서는 함수 표현식을 쓰길 권함.   스코프      참고 :            제로초님 블로그 함수의 범위(scope)       poiemaweb - 스코프                   변수의 유효범위.     스코프는 함수 호출이 아닌 함수 선언시 생성. -&gt; 렉시컬 스코핑(Lexical Scoping), 정적 스코핑     C-family language는 블록레벨 스코프. Js는 함수 레벨 스코프      var name = 'zero'; function log() {   console.log(name); }  function wrapper() {   name = 'nero'; // 1번   var name = 'nero'; // 2번   log(); } wrapper();   1번과 2번일때 결과가 다름.   실행 컨텍스트      참고 :            제로초님 블로그 실행 컨텍스트 - 더 자세한 예시 참고       Poiemaweb 실행 컨텍스트 - 실행 컨텍스트 그림설명 필독.              실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경.  생성된 실행 컨텍스트는 실행 컨텍스트 스택에 쌓임.  실행 컨텍스트 스택은 LIFO(후입선출) 의 방식으로 관리됨       실행 컨텍스트는 3가지 객체를 가짐.            Variable Object                    변수           매개변수(parameter)와 인수 정보(arguments)           함수 선언(함수 표현식은 제외)                       Scope Chain       this              전역 컨텍스트 생성 -&gt; 콜스택(실행 컨텍스트 스택)에 쌓임   함수 호출 시마다 컨텍스트 생성 -&gt; 콜스택(실행 컨텍스트 스택)에 쌓임   컨텍스트 생성 시 컨텍스트 안에 변수객체(arguments, variable), scope chain, this가 생성   컨텍스트 생성 후 함수실행. 사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾음   함수 실행이 마무리되면 해당 컨텍스트는 소멸.(클로저 제외)  -&gt; 콜스택(실행 컨텍스트 스택)에서 추출   페이지가 종료되면 전역 컨텍스트가 소멸 -&gt; 콜스택(실행 컨텍스트 스택)에서 추출   활성객체           실행 컨텍스트가 생성되면 자바스크립트 엔진은 해당 컨텍스트에서 실행에 필요한 여러가지 정보를 담을 객체를 생성한다. 이를 활성객체라 한다.     객체가 사용할 매개변수, 사용자가 정의한 변수 및 객체를 저장 한다.      클로저      참고 : poiemaweb - 클로저      클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다.   실행 컨텍스트의 관점에 설명하면, 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 활성 객체(Activation object)(변수, 함수 선언 등의 정보를 가지고 있다)는 내부함수에 의해 참조되는 한 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있는 것을 의미한다.    용도 :          상태유지     전역변수 사용억제     정보은닉(private 키워드 흉내)      //// 1번  var arr = [];  for (var i = 0; i &lt; 5; i++) {   arr[i] = function () {     return i;   }; }  for (var j = 0; j &lt; arr.length; j++) {   console.log(arr[j]()); }  //// 2번 var arr = [];  for (var i = 0; i &lt; 5; i++){   arr[i] = (function (id) {      return function () {       return id;      };   }(i));  }  for (var j = 0; j &lt; arr.length; j++) {   console.log(arr[j]()); }  //// 3번 const arr = [];  for (let i = 0; i &lt; 5; i++) {   arr[i] = function () {     return i;   }; }  for (let i = 0; i &lt; arr.length; i++) {   console.log(arr[i]()); }   1번 : 5 가 5번 출력 2번,3번 : 1,2,3,4,5 가 출력    ","categories": ["Javascript"],
        "tags": ["Skills"],
        "url": "https://seunghyum.github.io/javascript/Javascript-Concept/",
        "teaser":null},{
        "title": "[Algorithm] 방법론 공부",
        "excerpt":"동적 프로그래밍(Dynamic Programming)      기억하기 프로그래밍이라고도 함. 기법으로는 메모제이션, 분할정복을 많이 씀.    메모제이션(Memozation)           동일한 계산을 반복할때 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램의 실행 속도를 빠르게 하는 기술     하향식(Top-down) 계산법      분할 정복           문제를 해결이 가능한 더 작은 문제로 분할. 그 다음 작은 문제를 먼저 해결하고 그 결과를 활용하여 전체 문제를 해결하는 방법.     상향식(Bottom Up) 계산법             관련글 :            제로초님 - 동적 프로그래밍           관련 문제 :            이항계수 구하기       최단경로의 플로이드 알고리즘       최적화 문제       외판원 문제           내가 작성한 글            피보나치 수열 글                     그리디 알고리즘(Greedy Algorithm)      현재 상태에서 가장 좋다고 판단되는 것부터 선택하여 나가는 방법.   때로는 동적 프로그래밍 보다 그리디 알고리즘이 가장 효율적이고 간단할 때가 있기 때문에 알고리즘이 항상 최적인 해답을 주는지 확인이 필요함.  동적 프로그래밍과 같이 쓰이며 서로 보완하는 개념    역추적 기법(Back Tracking)      가능한 모든 방법을 빠짐없이 탐색하여 문제를 해결하는 방법.   이 기법은 데이터의 양이 조금만 늘어나도 실행시간이 엄청나게 늘어나기 때문에 불필요한 탐색을 하지 않기 위해 가지치기 전략을 구사하여 실행시간을 줄여야 함.    그래프 탐색 방법      깊이 우선 탐색(DFS - Depth First Search)   너비 우선 탐색(BFS - Breadth First Search)   ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "https://seunghyum.github.io/algorithm/Methodology/",
        "teaser":null},{
        "title": "[CodingTest] 2019-10-12 간단한 문제들(최대공약수, 최소공배수, 경우의 수)",
        "excerpt":"문제   /* 주어진 행렬(arr)에서 가장 낮은 수를 찾아서 그 수를 제외한 행렬을 리턴하라 */  // 예시 arr = [1,2,3,4]  answer = [2,3,4]   정답   function solution(arr) {   let answer = [];   let min = arr.reduce((a,b) =&gt; a &gt; b ? b : a)   arr.forEach((a,i) =&gt; {       if(a !== min) answer.push(a)   })   if (answer.length === 0) return [-1]   return answer; }     문제   /* 체육복 빌려주기 옆사람에게만 체육복 빌려줄 수 있음. 주어지는 인자는 n,lost,reserve n은 총 사람수 lost는 체육복 없는 사람 reserve는 체육복이 2개 있는 사람. 나머지는 체육복 1개만 있는 사람들. */  //예시 n = 5 lost = [2,4] reserve = [1,3,5]  answer = 5   정답   function solution(n, lost, reserve) {   let lostReserved = new Set()   let reserveSet = new Set(reserve)   lost.forEach(l =&gt; {       lostReserved.add(l-1)       lostReserved.add(l+1)   })   let noOfReserved = 0   reserve.forEach(ls =&gt; {       if(lostReserved.has(ls)) noOfReserved++   })   if(lost.length &lt; noOfReserved) noOfReserved = lost.length   let answer = n - lost.length + noOfReserved   return answer }     문제   /*   최대 공약수의 합 구하기   n = 12   [1,2,3,4,6,12] =&gt; 38 */  function solution(n) {   if(n &lt;= 1) return n   let last   let answer = 0   for(let i=1;i&lt;=n;i++) {       if(n%i===0) {           let a = n/i           if(last === a) break           last = i           if(i===a) return answer + i           answer += i + a       }   }    return answer }     문제   /*   두 수(n,m)의 최대공약수와 최소공배수 구하기    n = 1   m = 5   answer = [1, 10] */   내 답안   function solution(n, m) {    let a = n &gt; m ? n : m   let b = n &lt; m ? n : m    let GCD   let set = new Set()   for(let i=1;i&lt;=b;i++) {       if(b%i == 0) {           set.add(i)       }   }   set.forEach(s =&gt; {       if(a%s ==0) GCD = s   })    let LCM   if(a%b == 0) LCM = a   else LCM = a*b/GCD    return [GCD, LCM] }   더 좋은 답안   function gcd(a,b) {return b ? gcd(b,a%b) : Math.abs(a)}  function solution(n, m) {    let a = n &gt; m ? n : m   let b = n &lt; m ? n : m   let k = gcd(a,b)    return [k, a*b/k] })  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/SImple-2019.10.12/",
        "teaser":null},{
        "title": "[GraphQL] 공부",
        "excerpt":"   참고 자료 :            TutorialsPoint       GraphQL과 RESTful API           특징      하나의 Endpoint를 사용   요청할때 사용한 Query문에 따라 응답의 구조가 달라짐.   어떠한 프로토콜(TCP/Websocket) 에서도 사용가능.   NoSQL DB나 RDB 상관 없이 사용가능.   사용가능한 아키텍처 - 자세한 설명            GraphQL server with connected database       GraphQL server that integrates existing systems -&gt;       Hybrid approach           RESTful와 비교한 GraphQL의 장단점                  HTTP요청 횟수가 줄어듦.       RESTful은 원하는 리소스를 종류별로 다른 Endpoint에서 호출해야할 경우가 많음. 반면 GraphQL은 하나의 Endpoint에서 원하는 리소스를 모두 담아 요청하는 것이 가능.                       HTTP응답의 size가 줄어듦       필요한 부분만 요청할수 있음.           GraphQL? RESTful?  : GrpahQL과 RESTful은 각각의 장단점이 있음.   GraphQL     다양한 요청들에 응답해야할때.   대부분의 요청이 CRUD일때   RESTful     PDF, Excel File 전송같은 단순 Text로 처리되지 않는 요청이 있을때   요청의 구조가 다양하지 않고 정해져 있는경우.   API서버 구축시 두 방법을 섞어쓰는 것은 품질을 떨어뜨릴 수 있음. 각각의 장점을 살릴수 있는 설계가 필요.   문법      작업 유형            query: 데이터를 받아옴 - GET       mutation: 데이터를 생성(Post), 수정(PUT, PATCH), 삭제(DELETE)       subscription: 웹소켓을 사용해 실시간 양방향 통신 구현          ","categories": ["GraphQL"],
        "tags": ["GraphQL"],
        "url": "https://seunghyum.github.io/graphql/GraphQL/",
        "teaser":null},{
        "title": "[Web Skill] 이미지 스프라이트(Image Sprite)",
        "excerpt":"정의   필요한 이미지를 여러번 호출하는 것이 아니라 하나의 이미지 파일을 받아 Background로 Position을 잡아주어 여러개의 이미지를 가져올 수 있게 하는 방법.      장점 :            HTTP 요청횟수를 줄여 웹페이지의 로딩 시간을 절약함.       하나의 이미지 파일만 관리하면 됨.                단점 : 이미지를 불러오기 위해선 해당이미지의 Position을 알아야함. CSS로 관리할 경우 클래스로 분리하여 관리하고 background-image 속성으로 가져오면 편하지만 SVG이미지로 관리를 위해서는 js코드를 모듈화해야함.       관련링크 : Image Sprite Online Generator Sprite 이미지, CSS 클래스도 만들어줌.   적용해보기   적용대상 : 나의 Data Lab 프로젝트 중 18/19 UEFA 챔피언스리그 결과   변경 전 : 구단의 이미지 파일들을 각각 저장하여서 불러옴                                                기존 코드    downSeedNameBox.append('image')                   .attr('x', 10)                   .attr('y', SeedNameBox.margin/2)                   .attr('width', SeedNameBox.height - SeedNameBox.margin)                   .attr('height', SeedNameBox.height - SeedNameBox.margin)                   .attr('xlink:href', (d) =&gt; require(`@/assets/images/UEFA/Clubs/${d.participant[1].name}.png`))      문제점   토너먼트 내에서 여러번 이미지를 불러올 경우 이미지 역시 여러번 호출하고 있음.        개선 이후      전체 구단의 이미지들을 하나로 담은 파일을 만들고                                                   해당 구단이미지의 position을 저장하여서  뿌려주는 방식으로 변경함   images: {   Ajax: {     position: '5 5 70 70'     // ...   },   //... }  downSeedNameBox.append('svg')               .attr('x', 10)               .attr('y', SeedNameBox.margin/2)               .attr('width', SeedNameBox.height - SeedNameBox.margin)               .attr('height', SeedNameBox.height - SeedNameBox.margin)               .attr('viewBox', (d) =&gt; this.images[d.participant[1].name].position) // this.images['Ajax'].position             .append('image')               .attr('xlink:href', ClubsImage)  ","categories": ["Web Skill"],
        "tags": ["Image Sprite"],
        "url": "https://seunghyum.github.io/web%20skill/image-sprite/",
        "teaser":null},{
        "title": "[WebRTC] 공부",
        "excerpt":"WebRTC란?   Peer to Peer(P2P - 1:1) 통신을 가능하게 해주는 웹기술. 하지만 현실세계에선 클라이언트 간에 통신은 NAT(Network Access Translator) gateway가 있어서(네트워크 라우터같은) 대비책(fallback)이 필요. 그래서 STUN과 TURN같은 Signaling Server 가 있음.   ICE(Interactive Connectivity Establishment)      ICE(Interactive Connectivity Establishment)는 웹 브라우저 간에 피어 투 피어 접속을 할 수 있게 해 주는 프레임워크입니다.   A에서 B로 직접적인 피어 투 피어 접속이 쉽게 동작 하지 않는데는 많은 이유가 있습니다.   공개된 접속을 막는 방화벽을 통과해야 하기도 하고, 공인 IP 주소를 갖지 않은 기기들에 유일한 주소를 부여해야 하며, 라우터가 직접적인 피어 투 피어 연결을 지원하지 않는 경우 서버를 통해 데이터를 중계 해야 할 수도 있습니다.  이러한 이유들을 해결하기 위해 ICE는 아래에 기술된 기술들을 사용합니다.    - WebRTC 기술 약어 모음집 중에서 -    구조                                                STUN Server   클라이언트간의 메타데이터 정보(코덱, 파일유형, 클라이언트 IP주소)를 교환해주기 위한 서버   TURN Server   WebRTC를 통해 클라이언트 간 통신이 실패했을시 클라이언트에게 영상, 음성, 텍스트 등의 데이터 전달을 대신해주는 서버. Relay Server(방송서버) 역할을 함.   SDP (Session Description Protocol)      연결된 멀티미디어 데이터의 해상도, 형식, 코덱, 암호화 방법 등등을 기술하는 표준으로써, 피어 투 피어로 연결된 서로 간에 전송될 데이터를 이해하는데 사용됩니다.   SDP는 미디어 자체라기 보다는 메타데이터라고 볼 수 있습니다 - WebRTC 기술 약어 모음집 중에서 -    보안   Siginaling Server는 아직 WebRTC 표준이 아님(2019.10.22 기준). HTTPS나 localhost에서 동작하지만 개발자가 알아서 해야함.   P2P vs SFU vs MCU   퍼옴 : P2P vs SFU vs MCU   P2P는 1:1 방식에는 적합하나 1:N 통신으로는 부적합하다 그래서 등장한 것이 SFU, MCU                                                P2P (Peer to Peer)   중앙 서버 없이 종단 간 직접 연결 방식은 비용 측면에서 유리하나, 피어 수가 증가(mesh structure)할수록 시스템과 네트워크의 높은 capacity를 요구한다. 1:1 또는 소규모 미디어 교환에 적합하다.   SFU (Selective Forwarding Unit)   중앙 서버를 통해 종단 간 미디어 트래픽을 중계하는 중앙 서버 방식으로, 각 피어 연결 할당 및 decrypt/encrypt 처리 비용 정도를 감수한다. 영상 방송과 같은 1:M(or minimum-N:M) 스트리밍 서비스 구조에 적합하다.   MCU (Multi-point Control Unit)   다수의 송출 미디어를 중앙 서버에서 혼합(muxing) 또는 가공(transcoding)하여 수신측으로 전달하는 중앙 서버 방식으로, 클라이언트와 네트워크의 부담이 현저히 줄어드는 반면 중앙 서버의 높은 컴퓨팅 파워가 요구된다.   결론  : SFU가 더 좋다는 얘기가 많음.     MCU는 WebRTC의 최대 장점인 실시간성을 잡아먹음.   MCU는 decrypt/encrypt 과정에 비용이 많이 듦.   성능 측정해보니 Janus Gateway, Mediasoup이 좋음.(SFU)   참고한자료            주요 제품들의 성능을 체계적으로 비교분석한 글       MCU와 SFU의 처리과정을 도식화하여 설명한 글           참고자료     공식문서 한국어   따라하면서 배우는 튜토리얼   기술약어 모음집   마치며   현재 다니고 있는 회사는 실시간성, P2P 서버스가 핵심가치라 WebRTC를 선택했다. 하지만 1:M 서비스로 나아가려면 WebRTC에서 벗어나야 할수도 있을 것 같다. 스트리밍 서비스 관련 글들을 보니 회사가 앞으로 해야할 고민들이 조금은 보이고 있는것 같다.                                                   라이브 비디오 서비스 구축을 위한 노하우 - 1편   라이브 비디오 서비스 구축을 위한 노하우 - 2편  ","categories": ["WebRTC"],
        "tags": ["WebRTC"],
        "url": "https://seunghyum.github.io/webrtc/WebRTC/",
        "teaser":null},{
        "title": "[CodingTest] 2019-10-26 SQL문제",
        "excerpt":"공부겸 코딩테스트 사이트에서 토요일 오전 10시에 백엔드 포지션 테스트를 해준다기에 참여해봤다.  SQL문제가 나왔는데 더 좋은 답이 있는것 같아 나중에 기록해두고 수정해보기로 한다.    문제  Users 테이블의 ‘rice’, ‘candy’를 모두 구매한 유저를 찾는 쿼리를 만들어라.   결과값은 user_id를 내림차순으로 반환해라.                  user_id       ancestry                       1       rice                 1       chocolate                 2       candy                 3       cake                 3       cigar                 4       rice                 4       candy                 4       cake                 5       candy                 5       cake                 6       candy                 6       candy           처음에 짠 쿼리   SELECT BUY, NAME FROM USERS WHERE NAME IN ('rice', 'candy') GROUP BY USER_ID having count(BUY) = 2   이렇게 했을시                  user_id       ancestry                       6       candy                 6       candy           인 데이터는 걸러내지 못함.   수정한 쿼리   select USER_ID from (   SELECT DISTINCT USER_ID, NAME FROM USERS   WHERE NAME IN ('rice', 'candy') ) tmp GROUP BY USER_ID having count(NAME) = 2  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/SQL/",
        "teaser":null},{
        "title": "[CodingTest] 2019-10-26 모눈종이의 대각선에 위치한 1x1을 제외한 총 1x1의 개수",
        "excerpt":"문제   1cm x 1cm의 조합인 모눈종이 위에 가로 Wcm, 세로 Hcm인 사각형이 주어진다.  양끝 꼭지점 대각선에 접하는 1cm x 1cm 사각형을 제외한 1cm x 1cm 사각형의 개수를 구하라.     제출한 답   function solution(w, h) {   const x = w &gt; h ? w : h   const y = w &gt; h ? h : w   if (x % y === 0) return x * y - x   else {     const XperY = x / y     let k = 0     let iter = Math.floor(x / XperY)     let iter = Math.floor(x / XperY)     return x * y - (y + iter)   } }   설명   x : w와 h 중 큰값   y : w와 h 중 작은값      만약 w == h 경우   x가 대각선에 포함된 사각형의 개수   만약 w != h 경우   y의 좌표값이 1씩 커질 때마다 필요한 x의 개수를 구하고 y가 1이 커지는 순간(새로운 y+1축의 사각형)에 동일한 x좌표에 사각형이 2개있는 형태.                                                더 좋은 답   function solution(w, h) {   const x = w &gt; h ? w : h   const y = w &gt; h ? h : w   if (x % y === 0) return x * y - x   else {     return x * y - (x + y - 1)   } }   설명   w == h 일 경우만 대각선에 포함되는 사각형이 하나.  나머지의 경우는 대각선의 개수가 x + y - 1 이다. 대각선까지의 개수는 기본이 x의 개수. 추가되는 접점에서의 사각형은 y - 1(맨 마지막 접점의 경우 끝 모서리여서 추가되는 사각형이 없다).  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Test/",
        "teaser":null},{
        "title": "[ESlint & Prettier] 개발 관습 설정 in Visual Studio",
        "excerpt":"회사 프로젝트를 작업하기 전 프론트엔드 개발자들 간의 코드 규칙을 Eslint와 Prettier 설정을 맞춰 관리해가는 방향을 정했다.  아직 협업을 할 경우는 없지만 미래에 인수인계 받거나 협업을 진행할 경우 코드관습이 달라 고생할 경우를 대비하기로 했다.   설정은 작업을 진행하며 수정할 계획이다.   핵심은 저장할때마다 Eslint기준에 맞게 prettier 패키지가 코드를 수정하게 하는 것이다.   ESlint 설정   ESlint 설정을 위한 패키지 다운로드   $ npm i eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue --save-dev   프로젝트 루트에 있는 .eslintrc.json 파일 설정   module.exports = {   // 현재 eslintrc 파일을 기준으로 ESLint 규칙을 적용   root: true,   // 추가적인 규칙들을 적용   extends: [     'eslint:recommended',     'plugin:vue/essential',     'prettier',     'plugin:prettier/recommended',   ],   // 코드 정리 플러그인 추가   plugins: ['prettier'],   // 사용자 편의 규칙 추가   rules: {     'prettier/prettier': [       'error',       // 아래 규칙들은 개인 선호에 따라 prettier 문법 적용       // https://prettier.io/docs/en/options.html       {         singleQuote: true,         semi: false,         useTabs: true,         tabWidth: 2,         endOfLine: 'auto',         trailingComma: 'all',         printWidth: 80,         bracketSpacing: true,         arrowParens: 'avoid',       },     ],     'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',   }, };   Visual Studio 설정   Window : ctr + shift + p   Mac : cmd + shift + p   settings.json 파일 검색 후 설정   {   //  ....   \"editor.tabSize\": 2,   \"eslint.autoFixOnSave\": true, // 저장할때마다 js 코드 자동 수정   \"eslint.alwaysShowStatus\": true,   \"eslint.validate\": [     {       \"language\": \"vue\",       \"autoFix\": true     },     {       \"language\": \"javascript\",       \"autoFix\": true     },     {       \"language\": \"javascriptreact\",       \"autoFix\": true     }   ],   \"tslint.autoFixOnSave\": true, // 저장할때마다 typescript 코드 자동 수정   \"markdownlint.run\": \"onSave\" }   참고      VSCode 환경 설정 및 기초 사용법   Vue.js 개발 생산성을 높여주는 도구 3가지  ","categories": ["Code Config"],
        "tags": ["ESlint","Prettier","Visual Studio"],
        "url": "https://seunghyum.github.io/code%20config/Eslint-Prettier/",
        "teaser":null},{
        "title": "[DevOps] Linux Command 정리",
        "excerpt":"리눅스 관리하며 썼었던 커맨드들 정리   chkconfig  : 모든 서비스 리스트 나열, 추가 삭제 등 가능  참고 : GeeksForGeeks - chkconfig  ","categories": ["DevOps"],
        "tags": ["Linux Command"],
        "url": "https://seunghyum.github.io/devops/Linux-Command/",
        "teaser":null},{
        "title": "[CodingTest] Combination(조합) 문제풀이 2",
        "excerpt":"문제   : 옷 조합구하기      주어지는 clothes 배열을 조합하여 입을 수 있는 옷 조합 개수를 구하기   제한조건            최소 1개는 입어야함.       같은 카테고리의 옷은 못입음           작성한 답   function solution(clothes) {     let stats={}     clothes.forEach(e =&gt; {         if(!stats[e[1]]) stats[e[1]] = 1         else stats[e[1]]++;     })     const keys = clothes.keys()     const numOfkeys = keys.length     function getCombination(array, size, start, initialStuff)  {             if(initialStuff.length &gt;= size) {             combinationOfSet.push(initialStuff);         } else {             let i;             for(i=start;i&lt;array.length;++i) {                 getCombination(array, size, i+1,initialStuff.concat(array[i]))             }         }     }     for(let i=1;i&lt;=numOfkeys;i++) {         getCombination(keys,i,)     }     console.log(\"stats : \", stats) }  ","categories": ["CodingTest"],
        "tags": ["Javascript","Combination"],
        "url": "https://seunghyum.github.io/codingtest/Combination-2/",
        "teaser":null},{
        "title": "[CodingTest] Combination(조합) 문제풀이 1",
        "excerpt":"문제      주어진 숫자(nums) 중 3개의 수를 더했을 때,   소수가 되는 경우의 개수를 구하시오.   입출력 예시                  nums       Result                       [1,2,3,4]       1                 [1,2,7,6,4]       4           작성한 답   function solution(nums) {   const set = new Set(nums)   let combinationOfSet = []    function getCombination(array, size, start, initialStuff) {     if (initialStuff.length &gt;= size) {       combinationOfSet.push(initialStuff);     } else {       let i;       for (i = start; i &lt; array.length; ++i) {         getCombination(array, size, i + 1, initialStuff.concat(array[i]))       }     }   }   getCombination(Array.from(set), 3, 0, []);    function isPrime(num) {     for (let i = 2, s = Math.sqrt(num); i &lt;= s; i++)       if (num % i === 0) return false     return num &gt; 1;   }   let answer = 0   combinationOfSet.forEach(e =&gt; {     const multiply = e.reduce((a, b) =&gt; a + b)     if (isPrime(multiply)) answer++   })   return answer; }   참고한 자료      Number prime test in Javascript   Getting All Possible Combinations   배운점   : 소수를 구하는 방식    Stack Overflow관련 글 링크   만일 n이 소수가 아니고, n이 a와 b로 구성된다면 아래와 같다.  n = a * b   만약 a와 b 둘다 n의 제곱근 보다 크다면, a * b는 n보다 크다.  따라서 적어도 둘중 하나는 반드시 n의 제곱근보다 작거나 같아야한다.   그리고 만약 n의 제곱근보다 작거나 같은 수를 못구한다면 그 수는 소수이다.    코드로 나타내면 아래와 같다.   function isPrime(num) {   for (let i = 2, s = Math.sqrt(num); i &lt;= s; i++)     if (num % i === 0) return false   return num &gt; 1; }  ","categories": ["CodingTest"],
        "tags": ["Javascript","Combination"],
        "url": "https://seunghyum.github.io/codingtest/Combination-1/",
        "teaser":null}]
