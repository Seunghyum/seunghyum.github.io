var store = [{
        "title": "SGIS-shpToGeojson",
        "excerpt":"SGIS에서 받은 지도데이터(.shp)를 geojson으로 변경하는 작업 내용   2018년에 쓴 글을 재업로드하였습니다.   지도데이터 가공 과정     shapefile을 simplify를 진행.                     우선 mapshaper라는 shp파일 에디팅 툴로 편집. GUI온라인툴도 있음. 본인은 node CUI로 진행.           $ mapshaper -i 전환할 파일 \\             encoding=euc-kr  \\             -simplify weighted 0.5% \\ // 0.5%로 단순화             -o format=shapefile \\             바뀐 파일명.shp                           shapefile(R) -&gt; geojson 전환            ogr2ogr npm 라이브러리를 사용                    커맨드 :             $ ogr2ogr -f GeoJSON -t_srs crs:84 [geo json파일명] [shp파일명]                                    중요설명 : -t_srs crs:84 로 해줘야 제대로 projection이 됨(지도 투영법).           -&gt; 0.5%로 했더니 3~4MB인데 렌더링 시 느리다면 더 작게하는 것을 추천           -&gt; mapshaper로도 geojson을 만들 수 있지만 투영법 옵션이(-proj) 잘 안먹혀서 ogr2ogr, geo2topo를 적용함.                           만일 geojson에서 한글이 깨져서 나오는 경우     한글인코딩 문제            shpfile의 인코딩 에러. QGIS를 설치(로컬에서 shpfile을 수정할 수 있음)       QGIS 상단네비게이션 바의 “속성 테이블” 열기를 클릭해보면 한글 깨지는 것을 확인가능.       링크 로 들어가서 지시대로 하면 shpfile 인코딩에러 수정…. 아… 내 삽질….       shpfile로 다운로드는 해당 레이어를 우클릭  후 다른이름으로 저장하기 누르면 됨. 이후 다시 mapshaper, ogr2ogr 하면 됨.           projection(좌표계) 문제            막상 위의 한글문제를 해결해도 geojson파일을 열어보면 좌표계가 127.023168001711184, 37.578041688607954 의 형태가 아님.                이 문제는 한글 인코등 해결처럼 속성에서 좌표계를 스크롤 맨 밑의 사용자 정의 좌표계를           +proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m +no_defs                    로 정의 해야함. 정의한 다음 다시 다른 이름을 다운로드 진행.                   geojson -&gt; topojson으로 전환     npm topojson-client 설치   커맨드 : geo2topo [geo-json파일] &gt; [topo-json파일]   topojson 라이브러리는 현재 커맨드라인 툴이 사용불가. 반드시 topojson-client 설치 후 geo2topo로 할것. -Note also that topojson/topojson is no longer the command-line tools for manipulating TopoJSON — that’s all been put in the topojson/topojson-client repository.(출처)   -&gt; 0.5%로 했더니 3~4MB인데 렌더링 시 느리다면 더 작게하는 것을 추천   -&gt; mapshaper로도 topojson, geojson을 만들 수 있지만 투영법 옵션이(-proj) 잘 안먹혀서 ogr2ogr, geo2topo를 적용함.      느낀점 및 팁            gis데이터 가공은 projection(투영법) 설정이 중요.           활용가능한 결과물            통계청 파일 및 GeoJson 가공 데이터 파일       이름_simple.shp : 0.5%로 simplify한 shapefile       이름_geo.json : 가공한 GeoJson 파일       index.html : 예제 코드 browser-sync 같은 툴로 Application 형태로 띄워야 에러가 안남. 이유는 모르겠지만 포트로 안 띄우면 에러.           주의사항            geojson까지만 변경함. topojson까지는 변경하지 않음.          ","categories": ["DataProcessing"],
        "tags": ["ShapeFile","GeoJson","TopoJson","데이터 가공"],
        "url": "https://seunghyum.github.io/dataprocessing/SGIS-shpToGeojson/",
        "teaser":null},{
        "title": "[CodingTest] 별(*) 박스 만들기",
        "excerpt":"문제 설명     별(*) 박스 만들기   입력값 a(rows)와 b(cols)에 해당하는 별박스 만들기   예시 - 1  입력  4 2  출력  **** ****   예시 - 2  입력  3 5  출력  *** *** *** *** ***   내가 작성한 정답  solution(a,b) {   return (\"*\".repeat(a) + \"\\n\").repeat(b); }  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/star-box/",
        "teaser":null},{
        "title": "[CodingTest] 직사각형의 한점 좌표값 유추하기",
        "excerpt":"문제   직사각형을 만드는 데 필요한 4개의 점 중 3개의 좌표가 주어질 때, 나머지 한 점의 좌표를 구해 전체 좌표값들을 구해야한다.  점 3개의 좌표가 들어있는 배열 v가 매개변수로 주어질 때( v = [[x축 좌표, y축 좌표], … ] ), 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 return 하도록 solution 함수를 완성하라. 단, 직사각형의 각 변은 x축, y축에 평행하며, 반드시 직사각형을 만들 수 있는 경우만 입력으로 주어짐. 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 [x축 좌표, y축 좌표] 순으로 담아 return.   입출력 예                  insert       result                       [[1, 4], [3, 4], [3, 10]]       [1, 10]                 [[1, 1], [2, 2], [1, 2]]       [2, 1]           내가 작성한 답안   function solution(v) {     const rangeX = [             Math.max(v[0][0],v[1][0],v[2][0]),              Math.min(v[0][0],v[1][0],v[2][0])         ],         rangeY = [             Math.max(v[0][1],v[1][1],v[2][1]),              Math.min(v[0][1],v[1][1],v[2][1])         ],         stringfiedResult = [             JSON.stringify([rangeX[0], rangeY[0]]),             JSON.stringify([rangeX[0], rangeY[1]]),             JSON.stringify([rangeX[1], rangeY[0]]),             JSON.stringify([rangeX[1], rangeY[1]])         ],         stringfiedV = [             JSON.stringify(v[0]),              JSON.stringify(v[1]),             JSON.stringify(v[2])         ];     let answer     stringfiedResult.map(val =&gt; {         if(stringfiedV.indexOf(val) == -1) {             console.log(\"val : \", val)             answer = JSON.parse(val)         }     })     return answer }   내 답안풀이   직사각형이라면 모든 좌표들의 x축값은 a와 b 둘 중 하나이고 y축값 역시 c,d 둘 중 하나라고 생각했다. 그래서  [a,c], [b,c],  [a,d], [b,d]  의 형태일거라고 생각했다.   그래서 세 점의 좌표값들중  x축값들의 최소값, 최대값이 a와 b이고 =&gt; rangeX  y축값들의 최소값, 최대값이 c와 d이다. =&gt; rangeY   stringfiedResult는 그값들의 좌표값들이다.  stringfiedResult에서 없는 좌표값을 찾는 것이 내가 생각한 답이었다.   다른 사람들의 풀이   YanghaKoo 님이 푸신 식을 보면 더 간단하다.  function solution(v) {   var a = {}   var b = {}   const answer = []      v.forEach(r =&gt; {     if(a[r[0]]){       a[r[0]] = a[r[0]] +1     }else{       a[r[0]] = 1     }      if(b[r[1]]){       b[r[1]] = b[r[1]] +1     }else{       b[r[1]] = 1     }   });    for(var i in a){     if(a[i] === 1) {       answer.push(Number(i))       break;     }   }      for(var i in b){     if(b[i] === 1) {       answer.push(Number(i))       break;     }   }    return answer }   연산   v = [[1,4], [3,4], [3,10]]                  r       a       b                       [1,4]일때       {“1”:1}       {“4”: 1}                 [3,4]일때       {“1”:1, “3”:1}       {“4”: 2}                 [3,10]일때       {“1”:1, “3”:2}       {“4”: 1, “10”: 1}           연결배열로 input 값으로 주어진 각 숫자들의 출현빈도를 뽑고  뽑은 것들중 1번 출현한 숫자의 x,y축 값을 리턴하여 답을 내고 있다.   내 답의 경우 JSON.stringfy 매서드로 배열을 문자화시켜 그것들을 비교하고 있다.  문자화 연산의 비용을 고려하자면 연결배열로 문제를 해결하는 방법이 효율적이다.   실제 jsben.ch에서 테스트해본결과 내 로직보다 50% 더 효율적이었다.  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Rectangle-empty-point/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 1번 오픈채팅방 문제 with Javascript",
        "excerpt":"오픈채팅방     문제 바로가기 링크   카카오의 설명 블로그       나의 답안      function solution(record) {   let accounts = [], events = [], answer = [];        function setEnterProcess(message, userId, nickName) {       const findAccountByUserId = accounts.find(a =&gt; a.userId == userId)        if(findAccountByUserId &amp;&amp; findAccountByUserId.nickName !== nickName) findAccountByUserId.nickName = nickName;       else accounts.push({userId, nickName});                events.push({message, userId});   }        function setChangeProcess(userId, nickName) {       const findAccountByUserId = accounts.find(a =&gt; a.userId == userId)       findAccountByUserId.nickName = nickName   }        function setLeaveProcess(message, userId) {      events.push({message, userId})    }    record.map(r =&gt; {       const msgArray = r.split(\" \"),             message = msgArray[0],             userId = msgArray[1],             nickName = msgArray[2];       if(message == \"Enter\") setEnterProcess(message, userId, nickName);       else if(message == \"Change\") setChangeProcess(userId, nickName);       else if(message == \"Leave\") setLeaveProcess(message, userId);   })        events.map(e =&gt; {       const findAccountByUserId = accounts.find(a =&gt; a.userId == e.userId)       if(e.message == \"Enter\") answer.push(`${findAccountByUserId.nickName}님이 들어왔습니다.`)       else if(e.message == \"Leave\") answer.push(`${findAccountByUserId.nickName}님이 나갔습니다.`)   })        return answer; }                 테스트       Mocha 라이브러리 사용.     test.js      const assert = require('assert'); describe('test1', () =&gt; { describe('#연결배열', () =&gt; {   it('문제에서 제시한 테스트', () =&gt; {     assert.equal(       JSON.stringify(solution([\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\"])),       JSON.stringify([\"Prodo님이 들어왔습니다.\", \"Ryan님이 들어왔습니다.\", \"Prodo님이 나갔습니다.\", \"Prodo님이 들어왔습니다.\"])     );   });    it('기존 테스트에 추가한 로직을 추가한 테스트', () =&gt; {     assert.equal(       JSON.stringify(solution(         [           \"Enter uid1234 Muzi\",            \"Enter uid4567 Prodo\",           \"Leave uid1234\",           \"Enter uid1234 Prodo\",           \"Change uid4567 Ryan\",           \"Leave uid1234\",           \"Enter uid9990 Dave\",           \"Change uid9990 Kean\",           \"Enter uid1234 Jane\",         ]       )),       JSON.stringify([         \"Jane님이 들어왔습니다.\",          \"Ryan님이 들어왔습니다.\",          \"Jane님이 나갔습니다.\",          \"Jane님이 들어왔습니다.\",         \"Jane님이 나갔습니다.\",           \"Kean님이 들어왔습니다.\",          \"Jane님이 들어왔습니다.\"       ])     );   }); }); });                  느낀점  처음엔 events와 accounts를 같은 곳에 담고 관리하려고 했다.  [   {     {message: \"Enter\", userId: \"uid1234\", nickName: \"Muzi\"},     {message: \"Enter\", userId: \"uid4567\", nickName: \"Prodo\"},     ....   } ]  그러다보니 한 유저가 닉네임을 변경할때마다 모든 객체들을 탐색해야했다.  문제를 풀고 카카오의 해설 을 보니 “두 연결배열에 각각 accouts와 events에 담아 관리하면 쉽다”는 해설을 보고 코드를 다시 짰다.   해설을 보고나니 너무 간단해 허탈했다. 아직 갈길이 먼 것 같다.  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-open-chatting-room/",
        "teaser":null},{
        "title": "[CodingTest] Algospot - Anagram 문제",
        "excerpt":"  내가 작성한 답안  function solution(v) {   const inputs = v.split(\"\\n\"),          inputsLength = inputs.length;   let answer = \"\";    for(let i=1;i&lt;inputsLength;i++) {     let elements = inputs[i].split(\" \");     if(elements[0] == elements[1]) answer += \"No.\\n\";     else {       answer += elements[0].split(\"\").sort().reduce(reducer) == elements[1].split(\"\").sort().reduce((accumulator, currentValue) =&gt; accumulator + currentValue) ? \"YES\\n\" : \"No.\\n\";     }   }   return answer }    더 좋은 방식 찾기 - O(NlogN) 보다 낮은방법   Baekjoon 문제 - Anagram Generater     바로가기 링크     내가 작성한 답안  function solution(v) {   const inputs = v.split(\"\\n\"),          inputsLength = inputs.length;   let answers = \"\";      for(let i=1;i&lt;inputsLength;i++) { // 여러줄의 단어들 반복     const strings = inputs[i].split(\"\"),           stringsLength = strings.length;     let stringsStats = {}      for(let j=0;j&lt;stringsLength;j++) { // {a: 2, b:1, c: 1}       if(stringsStats[strings[j]]) stringsStats[strings[j]] += 1       else stringsStats[strings[j]] = 1     }      let initArray = []     for(s in stringsStats) {  // [a,b,c]       if(stringsStats[s] &gt; 0) initArray.push(s)       else continue;     }          let answer = \"\";     console.log(\"initArray : \", initArray)     console.log(\"stringsStats : \", stringsStats)     console.log(\"reduceStrings : \", reduceStrings(initArray, stringsStats, answer))   }   // return answer }  function reduceStrings(strings, stringsStats, answer) {   let stringArray = [...strings],       stats = {...stringsStats};    stringArray.forEach((sa)=&gt; {     newStringArray = [];      answer += sa;     stats[sa] -= 1;          for(s in stats) {       if(stats[s] &gt; 0) newStringArray.push(s);     }     console.log(\"sa : \", sa)     console.log(\"stringArray : \", stringArray)     console.log(\"stats : \", stats)     console.log(\"newStringArray : \", newStringArray)     console.log(\"answer : \", answer)     console.log(\"=========\")     if(newStringArray.length &gt; 0) reduceStrings(newStringArray, stats, answer);     else (answer += \"\\n\");   }) }   느낀점  처음 anagram 문제를 접한것은 같이 js를 공부하던 친구가 회사면접에서 받은 질문에서 시작되었다.  막상 나도 “그때 나였더라면 제대로 풀 수 있었을까?” 라는 생각에 접하게되었다.  아마 Youtube에 올라온 구글 면접 예시 영상의 분위기 였을것 같다. 링크   그다음 비슷한 문제가 어디있지 하며 찾은게 Algospot의 문제와 Backjoon 사이트의 문제였다.   Algospot의 문제는 생각했을때 비교적 간단했다. 두 문자열이 주어지고 같은지 비교만 하면 되었다.  하지만 Backjoon 사이트의 아나그램 문제를 풀어보며 “내가 js를 잘 이해하고 있는건가?” 라는 생각이 들었다.   Backjoon 사이트의 아나그램 문제는 하나의 문자열을 주고 그것에 해당하는 아나그램을 산출하라는 문제였다.  제한 조건은     알파벳 순서대로 나열할것   대소문자 구분할것   입력받은 철자들 중 중복되는 철자들이 있을경우, 중복해서 출력할 수 있으나 하나만 출력하라. ex) google -&gt; ggoole이 하나만 출력   문자열 풀이방식     받은 문자열을 array로 쪼개어 sorting하여 abc순으로 구성한다.   for문 재귀함수로 구성하여 n!로 문제를 해결   이라고 생각했다. 하지만 이럴경우 중복되는 문자들이 있을때 적절하게 문제를 해결하지 못했다.  가령 [a,a,b,c]가 있을떄 첫번째 문자가 b가 나올경우 [a,a,c]가 남는다는 것이다.  a는 1개로 취급되어야하는데 2개로 취급된다는 것이다.   내가 삽질을 하며 얻은 해결방법은     [a,a,b,c] 의 문자열을 루프를 돌때마다 하나씩 꺼내들고   {a:2, b:1, c:1}같은 형식의 객체로 루프를 돌때마다 문자열의 개수를 카운팅하고   카운팅한 객체들 중 0이 아닌 문자들을 배열에 담고[a,b,c]   1번을 다시 반복하며 배열에 문자가 하나도 없을때까지 반복한다. 는 것이었다.   하지만 이 루프를 돌며 반복하는 코드에서 스코프 문제가 발생했다.  ","categories": ["CodingTest"],
        "tags": ["Javascript","Algospot"],
        "url": "https://seunghyum.github.io/codingtest/Algospot-anagram/",
        "teaser":null},{
        "title": "[CodingTest] 매일 프로그래밍 - 피보나치 배열 2019-03-25",
        "excerpt":"      // 처음 답 function solution(n) {   if(n &lt; 2) return 0   let initN = [1,1], output = 0, result = 0;    while(n &gt; initN[0] + initN[1]) {     output = initN[0] + initN[1]     initN = [initN[1], output]     if(output%2 == 0) result += output   }    return result }  // 수정 후 function solution(n) {   if(n &lt; 2) return 0   let x = 1, y = 1, sum = 0;    while(n &gt; x) {     if(x%2 == 0) sum += x     let z = x + y     x = y     y = z   }    return sum }    ","categories": ["CodingTest"],
        "tags": ["Javascript","EverydayProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Every-Day-Programming-1/",
        "teaser":null},{
        "title": "[CodingTest] 매일 프로그래밍 - 2019-03-26",
        "excerpt":"문제  정수 배열(int array)가 주어지면 가장 큰 이어지는 원소들의 합을 구하시오. 단, 시간복잡도는 O(n).   Given an integer array, find the largest consecutive sum of elements.   예제  Input: [-1, 3, -1, 5]  Output: 7 // 3 + (-1) + 5    Input: [-5, -3, -1]  Output: -1 // -1    Input: [2, 4, -2, -3, 8]  Output: 9 // 2 + 4 + (-2) + (-3) + 8   내 풀이  난 중복된 수만 제오하고 합쳐라 라는 건줄 앎…. 문제에 대한 설명이 좀 더 정확했으면…  function solution(input) {   return [...new Set(input)].reduce((i, j) =&gt; i + j) }   정답  시간 복잡도: O(n)  공간 복잡도: O(1)  int solution(int[] arr) {   int maxSum = arr[0];   int currentSum = arr[0];   for(int i = 1; i &lt; arr.length; i++) {     currentSum = Math.max(currentSum + arr[i], arr[i]);     maxSum = Math.max(currentSum, maxSum);   }   return maxSum; }  ","categories": ["CodingTest"],
        "tags": ["Javascript","EverydayProgramming"],
        "url": "https://seunghyum.github.io/codingtest/Every-Day-Programming-2/",
        "teaser":null},{
        "title": "[CodingTest] 배열의 두 값을 합하여 k값 만들기",
        "excerpt":"문제  list라는 행렬과 k라는 자연수가 주어짐. list의 두 값을 합하여 k값을 만들 수 있으면 true, 없으면 false를 리턴해라.  보너스 : 한줄 표기   입력  let list = [3, 9, 10, 14], k = 12 solution(list, k) // =&gt; true   내가 풀어본 풀이  방법1 - 처음 풀어본 답안  function solution(list, k) {   for(let i = 0; i&lt;list.length;i++) {     for(let j = 1; j&lt;list.length;j++) {       if(list[i] + list[j] == k) return true      }   }   return false } // jsBench 기준 // 198,911,753 ops/s ±0.73% // fastest  풀어보고 나니 이 방식보다 더 좋은 방식. 한줄에 풀 수 있는 방식이 있나 궁금해졌다. 시간복잡도는 O(N2)이다.   방법2 - 한줄에 풀어본 답안  function solution(list, k) {   return list.some((currentVal,idx) =&gt; list.slice(idx+1).includes(k - currentVal)) } // jsBench 기준 // 17,822,052 ops/s ±1.82% // 91.04% slower (for문 중첩보다)  최대한 한줄에 풀어봄.  이렇게 할경우 한줄에는 쓸 수 있지만     루프(n)를 돌며 계속해서 slice를 해야한다는점.   루프(n)를 돌며 계속해서 includes매서드로 해당 인자가 포함되어있는지를 체크해야한다는점  때문에 효율적인지에 대한 의문이 있다.  차라리 중첩 for문으로 O(N2)번 푸는게 낫지 않을까 라는 생각이 든다.  benchmark를 해도 for문 중첩이 9 더 좋은 퍼포먼스를 내었다. jsBench   slice 매서드와 includes 매서드가 움직이는 방법식을 확인해보고 위의 한줄코드가 더 좋은 것인지 파악해봐야겠다.   slice 매서드 폴리필  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice  // 필요한 부분만 가져옴    Array.prototype.slice = function(begin, end) {   // 정의되지 않은 끝 인자로 IE &lt;9가 불만해진다.   end = (typeof end !== 'undefined') ? end : this.length;    // 네이티브 Array 객체의 경우 네이티브 slice 함수를 사용합니다.   if (Object.prototype.toString.call(this) === '[object Array]'){     return _slice.call(this, begin, end);    }    // object와 같은 배열을 위해 우리는 스스로 처리한다.   var i, cloned = [],     size, len = this.length;    // \"begin\"에 대한 음수 값을 처리합니다.   var start = begin || 0;   start = (start &gt;= 0) ? start : Math.max(0, len + start);    // \"end\"에 대한 음수 값을 처리합니다.   var upTo = (typeof end == 'number') ? Math.min(end, len) : len;   if (end &lt; 0) {     upTo = len + end;   }    // 슬라이스의 실제 예상 크기   size = upTo - start;    if (size &gt; 0) {     cloned = new Array(size);     if (this.charAt) {       for (i = 0; i &lt; size; i++) {         cloned[i] = this.charAt(start + i);       }     } else {       for (i = 0; i &lt; size; i++) {         cloned[i] = this[start + i];       }     }   }    return cloned; };  해당 배열을 for문으로 돌면서 조건과 일치하는 엘리먼트들을 가져옴.   includes 매서드 폴리필  // https://tc39.github.io/ecma262/#sec-array.prototype.includes if (!Array.prototype.includes) {   Object.defineProperty(Array.prototype, 'includes', {     value: function(searchElement, fromIndex) {        .       .       .        // 7. Repeat, while k &lt; len       while (k &lt; len) {         // a. Let elementK be the result of ? Get(O, ! ToString(k)).         // b. If SameValueZero(searchElement, elementK) is true, return true.         if (sameValueZero(o[k], searchElement)) {           return true;         }         // c. Increase k by 1.          k++;       }        // 8. Return false       return false;     }   }); }  위를 보면 includes매서드는 while문으로 배열을 탐색하고 찾으면 리턴하는 구조.   방법1의 경우 O(N2)보다 방법2는 O(N3) n번의 시간복잡도를 더 가지고 있다.  풀이해보자면  지금까지 내가 이해한 시간복잡도를 공식화 하자면     방법1 : 2n2 + 2n - 1 =&gt; O(N2)     function solution(list, k) { for(let i = 0; i&lt;list.length;i++) { // n   for(let j = 1; j&lt;list.length;j++) { // n * (n-1)     if(list[i] + list[j] == k) return true // (n-1) * (n-1)   } } return false }           방법2 : n * (n-1) * (n-1) =&gt; O(N3)     function solution(list, k) {  return list.some((currentVal,idx) =&gt; { // n   list.slice(idx+1) // n * (n-1)       .includes(k - currentVal) // n * (n-1) * (n-1) }) }           다른 사람들의 풀이 - Set을 이용  function solution(list, k) {   let seen = new Set();   for (let num of list) {     if(seen.has(k-num)) return true // O(1)     seen.add(num)   }   return false } solution([3, 9, 10, 14], 12)  iterate 하면서 이터레이팅 한 수들을 기억하여 찾아내는 방법.  배열의 요소들을 반복하면서 set에 우리가 지금까지 봤던 수들을 넣고 (seen 변수) 각 수마다 K값이 되기위해 필요한 수들을 seen에서 찾기   Set으로 이터레이팅하고있는 엘리먼트들을 기억하며 반복문을 돌린다. 이때의 시간복잡도는 O(N)라고 한다. ==&gt; 이해가 잘안간다. 결국 has 매서드로 다시 seen을 한바퀴 도는게 아닌가?   다른 사람들의 풀이 - 이진탐색으로 구하기 - 시간복잡도 O(nlogN) + O(1)  function binarySearch (list, value) {   // initial values for start, middle and end   let start = 0,       stop = list.length - 1,       middle = Math.floor((start + stop) / 2);    // While the middle is not what we're looking for and the list does not have a single item   while (list[middle] !== value &amp;&amp; start &lt; stop) {     if (value &lt; list[middle]) {       stop = middle - 1     } else {       start = middle + 1     }      // recalculate middle on every iteration     middle = Math.floor((start + stop) / 2)   }    // if the current middle item is what we're looking for return it's index, else return -1   return (list[middle] !== value) ? -1 : middle }  function solution(list, k) {   list.sort((a,b) =&gt; a-b); // O(logN)    for(let i=0;i&lt;list.length;i++) { // // O(n)     let target = k-item,         j = binarySearch(list, target); // O(n*logN)      if(j == -1) continue; // O(n*logN*1)     else if(j != i) return true;     else if(j + 1 &lt; list.length &amp;&amp; list[j + 1] == target) return true     else if(j - 1 &gt;= 0 &amp;&amp; list[j - 1] == target) return true   }   return false }   개념적으로 보자면 그래프에서 보듯이 어느 시점에서는 O(nlogN)이 O(n)보다 효율적일 수 있다.  그래서 두가지 방법을 혼용하는 것이 나은것 같다.   이해하는데 필요한 개념 &amp; 궁금한점     시간복잡도 Big O 표기법 개념   binary search 개념 및 구현            구현 관련 블로그 설명           성능을 제대로 비교해볼 수 있는 Benchmark 라이브러리 적용.   어느시점에서 nlogN이 N보다 효율인지 알 수 있나?  ","categories": ["CodingTest"],
        "tags": ["DailyProgramming","Javascript","BinarySearch","Set"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-1/",
        "teaser":null},{
        "title": "[DataType] Map & Set",
        "excerpt":"Set vs Array - 관련기사     Set            유일값들의 배열이 필요할때(distinct)       집합의 개념이 필요할때(차집합, 교집합 등등 자체 메서드들이 많음.)       index가 필요 없을때       Array에서 중복값을 없앨때 =&gt; new Set([1,1,2,3]) // 1,2,3       set의 add()는 O(n)의 시간복잡도가 소요되지만, Array의 push는 N(1)의 시간복잡도.           Array            요소들의 순서(order)가 필요할때       index가 필요할때 -&gt; Binaory Search           Map vs Object 관련기사     Map            key가 어떤타입도 될 수 있음.       저장한 key의 순서가 유지됨.       Object의 변형. Object와 동일 연산시 비용이 더 들어감.           Object            순수한 object의 나열일때 적합.       property에서 function 로직이 있을때 사용.       json 지원           읽어고 정리해야할 기사     data-structures-in-javascript   링크  ","categories": ["Data Type"],
        "tags": ["Data Type"],
        "url": "https://seunghyum.github.io/data%20type/Map-Set/",
        "teaser":null},{
        "title": "[CodingTest] i를 제외한 배열 요소들의 곱",
        "excerpt":"문제  정수 배열이 주어지면 인덱스 i에 해당하는 값 이외의 모든 값들의 곱인 배열을 구하여라.  보너스 : 나눗셈을 안쓰고 풀기   예시  [1,2,3] =&gt; [6,3,2] [1,2,3,4,5 ] =&gt; [120, 60, 40, 30, 24]   나눗셈이 있는 풀이법  // 2n =&gt; O(n) function solution(arr) {   const max = arr.reduce((a,b)=&gt;a*b); // n   let answer = [];   for(let el of arr) { // n + n     answer.push(max/el)   }   return answer }   나눗셈 없는 풀이법  // n^2 = N(n^2) function solution(arr) {   return arr.map(el =&gt; // n     arr.reduce((a,b) =&gt; { // n       return el == b ? a : a*b     },1)   ) }   느낀점     O(N2) 이외의 풀이법은 생각이 나지 않음.   답변 및 해설  function solution(arr) {     // Generate prefix solution     let prefix_products = []     for(el of arr) {       if (prefix_products.length &gt; 0) prefix_products.push(prefix_products[prefix_products.length-1] * el)       else prefix_products.push(el)     }     console.log(\"prefix_products : \", prefix_products)      // Generate suffix solution     let suffix_products = []     for(el of [...arr].reverse()) {       if(suffix_products.length &gt; 0) suffix_products.push(suffix_products[suffix_products.length-1] * el)       else suffix_products.push(el)     }     suffix_products = [...suffix_products].reverse();     console.log(\"suffix_products : \", suffix_products)      // Generate result     let result = []     for (let i=0; i&lt;arr.length; i++) {       if(i == 0) result.push(suffix_products[i + 1]) // 첫 엘리먼트       else if (i == arr.length - 1) result.push(prefix_products[i - 1]) // 마지막 엘리먼트       else result.push(prefix_products[i - 1] * suffix_products[i + 1])     }     console.log(\"result : \", result)     return result }  해결방법 : 루프를 돌면서 해당 인덱스(i)의 prefix(앞부분들)와 suffix(뒷부분들)의 값들을 구해서 곱하는 방법.   prefix는 i번째의 앞부분들의 수의 곱  suffix는 i번째의 뒷부분들의 수의 곱   result는 루프를 돌면서 i번째 앞부분들의 곱과 뒷부분들의 곱에 해당하는 element 값들 간의 곱   아이디어     n2이외의 방법을 위해 여러가지 n을 만들어 풀기.   i번째의 앞부분들의 곱과 뒷부분들의 곱에 해당하는 array추출.  ","categories": ["CodingTest"],
        "tags": ["DailyProgramming","Javascript","BinarySearch","Set"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming-2/",
        "teaser":null},{
        "title": "[Syntax] 새로 알게된 파이썬 문법 정리",
        "excerpt":"chaning comparison  파이썬은 chaning comparison이라는 신기한 문법이 있다. 참고  if a &lt; b and b &lt; c :   (...)  라는 구문이  if a &lt; b &lt; c :   (...)  으로 연산된다. 직관적인 문법이 인상적. Comparison operator Chaining 이라고 불린다.   Slice operater  특징  문자열, tuples, dictionaries, lists 에 모두 적용가능.   [start:end]  [1:5] is equivalent to \"from 1 to 5\" (5 not included) [1:] is equivalent to \"1 to end\" [len(a):] is equivalent to \"from length of a to end\"  List slicing   list[시작:끝:스텝]   list = [1,2,3,4,5,6,7]  &gt;&gt;&gt; list[0:3] # 끝 인덱스 값에 해당하는 요소값은 포함하지 않음. [1,2,3]  &gt;&gt;&gt; list[-5:-2] # 뒤에서 5번째 요소값부터 뒤에서 2번째 요소값 직전까지 [3,4,5]  &gt;&gt;&gt; list[-2:-1] # 뒤에서 2번째 요소값부터 뒤에서 1번째 요소값 직전까지 [6]  &gt;&gt;&gt; list[0:7:2] [1,3,5,7]   ","categories": ["Python","Syntax"],
        "tags": ["Python"],
        "url": "https://seunghyum.github.io/python/syntax/Python-Syntax/",
        "teaser":null},{
        "title": "[Network] 네트워크 공부내용 정리",
        "excerpt":"참고     책            그림으로 배우는 http &amp; network       http 완벽가이드               참고 사이트            그림으로 배우는 http &amp; network 정리글       http 완벽가이드 읽는법       zerocho 님 블로그 시리즈       wiki 백과(URI, URL, UDP)               글 작성 로그 및 수정 계획     2019.04.06 그림으로 배우는 http &amp; network 정리글 블로그를 읽고 정리한 글            실제 책(그림으로 배우는 http &amp; network) 읽고 한번 더 정리                    ch2 -&gt; 트랜잭션 생성에 따른 통신 과정 - 2019.04.15           ch3  -&gt; 데이터 타입에 따른                       http 완벽 가이드 다시 읽고 정리 &lt;- http 완벽가이드 읽는법       CORS, CORB 에러 정리       쿠키 / 캐시 정리               TCP/IP   인터넷과 관련된 프로토콜을 모아놓은 것   대부분, IP프로토콜을 사용한 통신에서 사용되고 있는 프로토콜을 총칭해서 TCP/IP라고 함.  설계를 편하게 하고 유지보수를 위해서 계층화가 되어있음.     4계층            애플리케이션 계층 - 유저에서 제공되는 에플리케이션 (FTP, DNS, HTTP)       트랜스포트 계층 - 에플리케이션 계층에 네트워크로 접속되어 있는 컴퓨터사이의 데이터흐름을 제공(TCP, UDP)       네트워크 계층 - 네트워크 상에서 패킷의 이동을 다룸. 여러대의 컴퓨터랑 네트워크 기기사이에서 길을 찾는 것(IP)                    패킷 : 전송하는 데이터의 최소 단위                       링크 계층 - 네트워크의 하드웨어적인 면 (케이블 등등)      HTTP 데이터 -&gt; TCP 헤더 -&gt; IP 헤더 -&gt; Eternet 헤더           IP      배송을 담당. 개개의 패킷을 상대방에게 전달. IP주소와 MAC(변경 불가)주소를 통해서 통신   어느 누구도 길에대한 정확한 위치를 알고 있지 않음(물어물어 찾아감)   네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것. 각 기기에 할당되는 것이 아니라 기기에 장착된 각각의 네트워크용 하드웨어에 할당 됨. 즉, 복수의 네트워크하드웨어를 장착한 기기는 복수의 주소 할당.   MAC(Media Access Control Address) 주소 :  IEEE에서 표준화된 LAN 방식의 기기는 모두 같은 형식의 주소를 사용하는데 이 주소를 가르킴. MAC주소를 사용하여 목적지를 찾아갈때는 ARP라는 프로토콜이 사용됨   IP주소는 변경가능하나, MAC주소는 변경불가.   TCP(Transfer Control Protocol)      신뢰성을 담당            바이트 스트림 서비스  : 큰 데이터를 보내기위에 TCP세그먼트라고 불리우는 단위 패킷으로 작개 분해하여 관리하는것. 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할.       TCP Three way hand shaking (STN/ACK 플래그 사용)  : SYN으로 보내면 SYN/ACK 플래그로 패킷 수신한 사실을 전하면 ACK 플래그를 다시 보내 완료되었음을 전송. 도중에 끊키면 다시 반복            DNS(Domain Name System)   : 도메인을 주면 IP주소를 반환해줌   HTTP      클라이언트(웹브라우저)에서 서버까지 일련의 흐름을 결정하는 프로토콜   HTTP자체는 잘 변하지 않음. 현재는 1997년 공개된 HTTP/1.1을 대부분 쓰고있음. 2.0이 탄생되었지만 표준화까지 시간이 오래걸림   URI, URL   URI(Uniform Resource Identifiers)  스키마를 나타내는 리소스를 식별하기 위한 식별자.  스키마: 리소스를 얻기위한 수단에 이름을 붙이는 방법. (http, ftp, mailto, file, telnet 등).      Uniform            통일된(Uniformity) 서식을 결정하는 것. 여러가지 종류의 리소스 지정을 구별없이 같은 맥락에서 사용할 수 있게 한다. (응??) 또한, 새로운 스키마(http:와 ftp등) 도입을 용이하게 함           Resource            식별가능한 모든 것. (도큐먼트 파일, 이미지, 서비스(ex. 오늘의 일기예보) 등 다른 것과 구별할 수 있는 것은 모두 리소스) 단일한 부분만 아니라 복수의 집합도 리소스임           Identifier            식별자. 식별 가능한 것을 참조하는 오브젝트.           URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해   URL은 리소스의 장소(네트워크상의 위치)를 나타낸다.   URL은 URI의 서브셋이다. (URI = URL + URN)      URL 포맷       URL 설명       예시  http://user:pass@www.aaa.com:80/dir/index.html?uid=12#head1    예시 풀이    http://    user:pass   @www.aaa.com     :80     /dir/index.html    ?uid=12           #head1 스키마(http),   자격정보,       서버주소,      서버포트,     계층적파일경로,     쿼리문자열,     프래그먼트식별자(#head1)      스키마            리소스를 얻기위해 사용하는 프로토콜을 지시.       대소문자 무시, 마지막에 콜론(:)이 붙음.       “data:”, “javascript:”같이 데이터와 프로그램도 지정 가능.           자격정보(=크리덴셜)            서버로부터 리소스를 취득하려면 자격정보가 필요.       유저명과 패스워드 지정. 이것은 옵션.           서버주소 : DNS이름(www.aaa.com)이나, IPv4주소(192.168.1.1)나, IPv6주소([0:0:0:0:0:0:0:1])를 쓸 수 있음.   서버포트 : 서버의 접속대상이 되는 네트워크 포트 번호 지정. 이것도 옵션. 생략시 디폴트 포트가 사용   계층적 파일경로 : 특정 리소스를 식별하기 위해 서버상의 파일 패스를 지정.   쿼리문자열 : 파일 패스로 지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리문자열을 사용. 옵션값   프래그먼트 식별자 : 취득한 리소스에서 서브리소스 (도큐먼트 중간에 위치)를 가리키기 위해서 사용. 옵션값   UDP와 TCP 비교[편집]   TCP는 데이터를 주고 받을 양단 간에 먼저 연결을 설정하고 설정된 연결을 통해 양방향으로 데이터를 전송하지만, UDP는 연결을 설정하지 않고 수신자가 데이터를 받을 준비를 확인하는 단계를 거치지 않고 단방향으로 정보를 전송한다.     신뢰성 - TCP는 메시지 수신을 확인하지만 UDP는 수신자가 메시지를 수신했는지 확인할 수 없다.   순서 정렬 - TCP에서는 메시지가 보내진 순서를 보장하기 위해 재조립하지만 UDP는 메시지 도착 순서를 예측할 수 없다.   부하 - TCP보다 속도가 일반적으로 빠르고 오버헤드가 적다.       간단한 프로토콜 HTTP   하나의 트랜젝션     TCP커넥션 연결 (쓰리웨이 핸드쉐이킹)     HTTP요청   HTTP응답     TCP커넥션 종료         HTTP는 스테이트리스(Stateless)프로토콜이다. 과거에 교환했던 리퀘스트와 리스폰스의 상태를 관리하지 않음.  이점도 있지만 이로인한 문제를 해결하기 위한 시스템 : 쿠키   쿠키 - HTTP 프로토콜의 스테이트리스 단점을 보완.  클라이언트 상태 파악하기 위함.   서버에서 리스폰스로 보내진 Set-Cookie라는 헤더필드에 의해 쿠키를 클라이언트에 보존.   다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키값을 넣어서 송신.   서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버상의 기록을 확인해서 이전 상태를 알 수 있음.      HTTP 매서드      GET : 리소스 획득   POST : 엔티티 전송.   PUT : 파일전송. FTP에 의한 파일전송과 같이 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하다록 요구. 인증기능이 없어서 REST를 사용하는 경우에 사용. entity의 전체(ex - 모든 fields)를 바꿈(update)   PATCH : entity의 일부만 바꿈(ex - 일부 fields)를 바꿈.            참고(스프링에서의 정의) PUT replaces an existing entity. If only a subset of data elements are provided, the rest will be replaced with empty or null.           DELETE : 파일 삭제. PUT매서드와 반대. 인증기능이 없어서 REST를 사용하는 경우에 사용.   HEAD : GET과 같은 기능이지만 메시지 바디는 반환 안함. URI 유효성과 리소스 갱신 시간을 확인하는 목적으로 사용.   OPTIONS : 제공하고 있는 메소드의 문의. 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하는데 사용함.   TRACE : 경로조사. 프록시등을 중계할떄 추적위해 사용. 크로스 사이트 트레이싱(XST) 같은 공격을 일으킬 수 있으므로 거의 안쓰임. “Max-Forwards”라는 헤더 필드에 수치를 포함시켜 요청하면 서버를 통과할때마다 그 수치를 줄여나감. 수치가 0이 된 곳을 끝으로 200 OK 리스폰스 보냄.   CONNECT : 프록시에 터널링 요구. TCP 통신을 터널링 시키기 위해서 사용함. 주로 SSL, TLS등의 프로토콜로 암호화된 것을 터널링 시키기 위해서 사용.   HTTP 상태 코드      1xx 정보   2xx 성공(Success)   3xx 리다이렉트(Redirection)   4xx 클라이언트 에러(Client Error)   5xx 서버 에러(Server Error)   웹의 여러 애플리케이션   프록시 : 클라이언트와 서버사이에 위치한 HTTP 중개자   서버와 클라이언트 사이에서 중계 프로그램. 웹 보안, 어플리케이션 통합, 성능 최적화에 쓰임.  모든 웹 트래픽 흐름속에서 신뢰할 만한 중개자 역할을 한다.  요청과 응답을 필터링한다.  무언가를 다운받을 때 애플리케이션 바이러스를 검출하거나, 초등학교 학생들에게서 성인 콘텐츠를 차단한다.       캐시 : 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고   프록시서버와 클라이언트 로컬디스크에 보관된 리소스 사본.  자주 찾는 것의 사본을 저장해두는 특별한 종류의 http프락시 서버다.  리소스를 가진 서버에 엑세스를 줄이는 것이 가능하기 때문에 통신량과 통신시간을 절약할 수 있다.        게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹서버   다른 서버들의 중개자. 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용.  게이트웨이는 언제나 스스로가 리소스를 갖고있는 진짜 서버인 것처럼 요청을 다룸.  클라이언트는 자신이 게이트웨이와 통신하는 것을 알지못함.  예를들어 HTTP/FTP 게이트웨이는 GTP URI에 대한 HTTP요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옴. 받아온 문서는 HTTP메시지에 담겨 클라이언트에게 보냄.        터널 : 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시   에이전트 : 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트   ","categories": ["Network"],
        "tags": ["Network"],
        "url": "https://seunghyum.github.io/network/Network/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 2번 실패율 문제 with Javascript",
        "excerpt":"오픈채팅방     문제 바로가기 링크   카카오의 설명 블로그     나의 첫답안  function solution(N, stages) {   let st = stages, stats = [];   for(let i=1;i&lt;N+1;i++){ // n     let selectedNumbers=0, obj = {};     st = st.filter((s)=&gt;{ // n * n       if(s == i) selectedNumbers++;       else return true;     });     obj.name = i;     obj.per = (st.length == 0 ? 1 : selectedNumbers/st.length);     stats.push(obj)   }   stats.sort((a,b)=&gt; a.per - b.per &gt;= 0 ? -1 : 1) // n^2 + logN   return stats.map(s =&gt; s.name) // -&gt; O(n^2) }   나의 수정한 답안  function solution(N, stages) {   let eaStats = {}, perStats = [];    for(let el of stages) { // Array 인자값들의 갯수 통계를 내고 = easStats -&gt; n     if(!eaStats[el]) eaStats[el] = 1;     else eaStats[el]++;   }    let stageUsers = stages.length;    for(let i=1;i&lt;N+1;i++){ // 갯수통계(eaStats)를 확률들의 통계(perStats)로 다시 변환하고 -&gt; 2n     let perStatsObj = {}     if(!eaStats[i]) {       perStatsObj.name = i;       perStatsObj.per = 0;       perStats.push(perStatsObj)     } else {       perStatsObj.name = i       perStatsObj.per = stageUsers == 0 ? 1 : eaStats[i]/stageUsers;       stageUsers = stageUsers - eaStats[i];       perStats.push(perStatsObj)     }   }    perStats.sort((a,b)=&gt; a.per - b.per &gt;= 0 ? -1 : 1) // 확률들의 통계(perStats)로 다시 변환하고 -&gt; 2n + nlogN   return perStats.map(s =&gt; s.name) // -&gt; O(nlogN) }   결과 비교   나의 첫답안    나의 수정한 답안       공부해야할 자료  sort 매서드는 merge sort라고 한다. 관련링크  다른 sort들의 특징과 장점을 봐야겠다.     JS Interview Question   Sort Algorithms with Javascript  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-failure-rate/",
        "teaser":null},{
        "title": "[CodingTest] 2019 네이버 핵데이 코드테스트 문제3 with Javascript",
        "excerpt":"문제3  문제를 알려줄 수 없다는 답변 받음. github에서 네이버 핵데이 검색하면 나옴.   내가 작성한 답변 - 아래로 꺾인선만 구하기  function solution(N) {   let maxUnderCurvedPoint = N[0];   for(let i=0;i&lt;=N.length;i++) {     if(N[i]&gt;N[i+1] &amp;&amp; maxUnderCurvedPoint &gt; N[i]) maxUnderCurvedPoint = N[i];   }   for(let i=N.length-1;i&gt;=0;i--) {     if (maxUnderCurvedPoint &lt; N[i]) return i-1   } }  풀이해석          예시              생각했던 과정         부족했던 점  N = [0,4,-1,3,10] // 이 경우를 제대로 못구함.  내 답은 단순히 아래로꺾은선 만을 고려하였고 위로꺾은 선은 고려하지 않았다.  그래서 위의 예시처럼 첫번째 위로꺾은 선이 앞쪽에 배치될 경우 걸러내지 못했다.   수정한 답안1 - 위로꺾인선, 아래로꺾인선 구하기  function solution(N) {   let maxUnderCurvedPoint = N[0], maxUpperCurvedPoint = N[0];   for(let i=0;i&lt;=N.length;i++) {     if(N[i]&lt;N[i+1] &amp;&amp; maxUnderCurvedPoint &lt; N[i]) maxUnderCurvedPoint = N[i];     else if(N[i]&gt;N[i+1] &amp;&amp; maxUpperCurvedPoint &lt; N[i]) maxUpperCurvedPoint = N[i]; // 추가   }   for(let i=N.length-1;i&gt;=0;i--) {     if (maxUnderCurvedPoint &lt; N[i] &amp;&amp; maxUpperCurvedPoint &lt; N[i]) return i; // 수정   } }  부족한 점  다시생각해보니 위로 꺾인선만 고려하면 쉽게 답이 나옴.   수정한 답안2 - 위로꺾인선만 구하기  function solution(N) {   let maxUpperCurvedPoint = N[0];   for(let i=0;i&lt;=N.length;i++) {     if(N[i]&gt;N[i+1] &amp;&amp; maxUpperCurvedPoint &gt; N[i]) maxUpperCurvedPoint = N[i]; // 추가   }      for(let i=N.length-1;i&gt;=0;i--) {     if (maxUpperCurvedPoint &lt; N[i]) return i; // 수정   } } console.log(\"solution([-5,-5,3,10]) : \", solution([-5,-5,3,10])) console.log(\"solution([3,-5,5,10]) : \", solution([3,-5,5,10]))   느낀점  답에 대한 테스트케이스를 여러개 생각해서 검토하지 않아서 오류를 놓침.  여러가지 테스트케이스를 해보고 오류점검하는 버릇이 좀 더 들어야함.  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Naver-Hackday-Test-3/",
        "teaser":null},{
        "title": "[CodingTest] 2019 네이버 핵데이 코드테스트 문제1 with Javascript",
        "excerpt":"문제1  문제를 알려줄 수 없다는 답변 받음. github에서 네이버 핵데이 검색하면 나옴.   내가 작성한 답변  function solution(A) {   const oppositeGroupA = new Set([1,6]),         oppositeGroupB = new Set([2,5]),         oppositeGroupC = new Set([3,4]);      let stats = {},       maxEl = A[0],        maxCount = 1,       answer = 0;   // 가장 많이 중복되는 el을 기준.   // return = 기준 숫자의 반대편 숫자의 갯수 * 2 + 다른 숫자면들의 개수들    for(let i = 0; i &lt; A.length; i++) {     let el = A[i];     if(stats[el] == null) stats[el] = 1;     else stats[el]++;       if(stats[el] &gt; maxCount) {       maxEl = el;       maxCount = stats[el];     }   }   for(let s in stats) {     let NumberS = Number(s);     if(maxEl == NumberS) continue;     else if(oppositeGroupA.has(maxEl) &amp;&amp; oppositeGroupA.has(NumberS)) answer += stats[s] * 2;     else if(oppositeGroupB.has(maxEl) &amp;&amp; oppositeGroupB.has(NumberS)) answer += stats[s] * 2;     else if(oppositeGroupC.has(maxEl) &amp;&amp; oppositeGroupC.has(NumberS)) answer += stats[s] * 2;     else answer += stats[s];   }   return answer; }  console.log(\"1,2,3 : \", solution([1,2,3])) console.log(\"1,1,6 : \", solution([1,1,6])) console.log(\"1,6,2,3 : \", solution([1,6,2,3])) console.log(\"1,1,2,3,6 : \", solution([1,1,2,3,6]))   수정한 답변  function solution(A) {   let stats = {},       maxEl = A[0],        maxCount = 1,       answer = 0;          for(let i = 0; i &lt; A.length; i++) {     let el = A[i];     if(stats[el] == null) stats[el] = 1;     else stats[el]++;       if(stats[el] &gt; maxCount) {       maxEl = el;       maxCount = stats[el];     }   }    for(let s in stats) {     let NumberS = Number(s);     if(maxEl == NumberS) continue;     else if(maxEl + NumberS === 7) answer += stats[s] * 2;     else answer += stats[s];   }   return answer; }  console.log(\"2,2,2,3,4,5,6 : \", solution([2,2,2,3,4,5,6 ]))     괜히 쓸데없이 oppositeGroupA 같은 형식으로 구하려고했다. 단순하게 maxEl + NumberS === 7 으로 했으면 더 좋았을텐데…  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Naver-Hackday-Test-1/",
        "teaser":null},{
        "title": "[CodingTest] 벽안에 고인 빗물의 양",
        "excerpt":"문제   주어지는 행렬 arr(ex - [3,0,1,3,0,5])값의 인자들을 벽이라고 했을때 비가와서 물이 고이는 부분의 양을 구하여라.      답 : 8   내가 생각한 풀이      풀어본 시간 : 1시간   중간까지 밖에 못함. 접근방법이 복잡해져서 방향을 잘못잡음.            위로 꺾은 선들을 찾아서 각 구간마다 물이 고일수있는 max값을 찾고       해당 구간에서 max - arr[i] 값들의 합을 구하려고 했음           function solution(arr) {     let upperPoints = {0: arr[0]} // {index: value, ...}     for(let i=0;i&gt;arr.length;i++) {         if(arr[i-1] &lt; arr[i]) if(arr[i+1] == undefined) upperPoints[i] = arr[i]         else if(arr[i] &gt; arr[i+1]) upperPoints[i] = arr[i]     }      let filteredPoints = {0: arr[0]}, // {index: value, ...}         startPoint = [0, arr[0]]     for((p,i) of upperPoints) {         if(&amp;&amp; startPoint &gt;= upperPoints[i] &amp;&amp; i != 0 ) {             filteredPoints[i] = upperPoints[i];         }     }      // 중단함. }    정답풀이법      아이디어            왼쪽과 오른쪽을 각각 돌며 각 index마다의 물이 고일 수 있는 max값 찾음.       왼쪽 / 오른쪽에서 찾은 max값들 중 min 값으로 [min - 해당 index] 값을 구해서 total로 더함.           // 시간복잡도 O(n) 공간복잡도 O(n) function solution(arr) {     let left_maxes = [],          right_maxes = [],         current_left_max = 0,          current_right_max = 0,          total = 0;      for(let i=0; arr.length &gt; i; i++) {         current_left_max = Math.max(current_left_max, arr[i]);         left_maxes[i] = current_left_max;     }          for(let i=arr.length-1; 0 &lt;= i; i--) {         current_right_max = Math.max(current_right_max, arr[i]);         right_maxes[i] = current_right_max;     }      for(let i=0; arr.length &gt; i; i++) {         total += Math.min(left_maxes[i], right_maxes[i]) - arr[i];     }     return total; }   업그레이드된 정답풀이법      목적            공간 복잡도를 O(1)로 만들기위해 left_maxes, right_maxes를 없앰.           아이디어            가장 큰 수를 기점으로 오른쪽 / 왼쪽 나눔.           단점            울퉁불퉁한 모양이면 답이 제대로 나오지만 계단형태의 그래프일 경우 답이 이상하게 나옴.       arr = [1,2,3,4,5] 또는 [5,4,3,2,1]의 경우 답이 -3 나옴.       arr = [5,2,6,1,8,9,9,7] 에 해당하는 답안이 이상함.       arr = [3,0,1,3,0,5] 에만 잘 되는 답임.           // 시간복잡도 O(n) 공간복잡도 O(1) function solution(arr) {     if (arr.length == 0) return 0      let total = 0,         max_i = arr.indexOf(Math.max(...arr)),         left_max = arr[0],         right_max = arr[arr.length-1];      for (let i=1; max_i &gt; i; i++) {         total += left_max - arr[i];         left_max = Math.max(left_max, arr[i]);     }      for (let i=arr.length-2; max_i&lt;i; i--) {         total += right_max - arr[i];         right_max = Math.max(right_max, arr[i]);     }      return total; }  ","categories": ["CodingTest"],
        "tags": ["DailyProgramming","Javascript","BinarySearch","Set"],
        "url": "https://seunghyum.github.io/codingtest/Daily-Programming/",
        "teaser":null},{
        "title": "[Algorithm] 유클리드 호제법(최대공약수 구하기) 공부",
        "excerpt":"정의      유클리드 호제법(- 互除法, Euclidean Algorithm)은 2개의 자연수 또는 정식(整式)의 최대공약수(Greatest Common Divisor)를 구하는 알고리즘의 하나이다.     호제법이란 말은 두 수가 서로(互) 상대방 수를 나누어(除)서 결국 원하는 수를 얻는 알고리즘을 나타낸다.     2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a&gt;b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.   이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고, 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.      이는 명시적으로 기술된 가장 오래된 알고리즘으로서도 알려져 있으며, 기원전 300년경에 쓰인 유클리드의 《원론》 제7권, 명제 1부터 3까지에 해당한다.      - 위키백과, 우리 모두의 백과사전.           설명   글설명      칸아카데미 참고   270과 192의 최대공약수 - GCD(270,192)          GCD(270,192) - 270과 192의 최대공약수 찾기            A=270, B=192       A ≠ 0       B ≠ 0           270 = 192 * 1 +78         GCD(270,192)=GCD(192,78) - 이기 때문에 192와 78의 최대공약수 찾기            A=192, B=78       A ≠0       B ≠0           192 = 78 * 2 + 36          GCD(192,78)=GCD(78,36) - 이기 때문에 78과 36의 최대공약수 찾기            A=78, B=36       A ≠0       B ≠0           78 = 36 * 2 + 6          GCD(78,36)=GCD(36,6) - 이기 때문에 36과 6의 최대공약수 찾기            A=36, B=6       A ≠0       B ≠0  36 = 6 * 6 + 0              GCD(36,6)=GCD(6,0) - 이기 때문에 6과 0의 최대공약수 찾기            A=6, B=0       A ≠0       B =0, GCD(6,0)=6              지금까지의 과정 :   GCD(270,192) = GCD(192,78) = GCD(78,36) = GCD(36,6) = GCD(6,0) = 6   GCD(270,192) = 6    그림설명      106와 16의 최대공약수 구하기 - GCD(106,16)           관련 코드   파이썬 코드   # 방법1 def gcd(m,n): # gcd == \"Greatest Common Divisor\" \tif m &lt; n: \t\tm, n = n, m \tif n == 0: \t\treturn m     if m % n == 0: \t\treturn n \telse: \t\treturn gcd(n, m%n)   # 방법2 def gcd(m,n):     while n != 0:        t = m%n        (m,n) = (n,t)     return abs(m)  # 방법3 def gcd(m,n):     while n! = 0: \t    if m &lt; n: \t\t    m, n = n, m \t    if n == 0: \t\t    return m \t    if m % n == 0: \t\t    return n    자바코드    public static int gcd(int p, int q)  { \tif (q == 0) return p; \treturn gcd(q, p%q);  }   자바스크립트코드      freeCodeCamp 참고   Javascript Code to Perform GCD   function gcd(a, b) { // 단, a가 b보다 커야함.   var R;   while ((a % b) &gt; 0)  {     R = a % b;     a = b;     b = R;   }   return b; }   Javascript Code to Perform GCD using Recursion   function gcd(a, b) { // 단, a가 b보다 커야함.   if (b == 0)     return a;   else     return gcd(b, (a % b)); }  ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "https://seunghyum.github.io/algorithm/Euclidean-algorithm/",
        "teaser":null},{
        "title": "[CodingTest] 2019 카카오 신입 공채 1차 - 4번 무지의 먹방 라이브 문제 with Javascript",
        "excerpt":"무지의 먹방 라이브      문제 바로가기 링크   카카오의 설명 블로그     나의 답안   function solution(food_times, k) {     if(food_times.length &gt; k) return k+1      const val = k / food_times.length,           rest = k % food_times.length,           timesSum = food_times.reduce((a, b) =&gt; a + b);          if(timesSum &lt;= k) return -1;          let count = 0;     for(let i=0;timesSum&gt;i;i++) {         const idx = i%food_times.length         if(food_times[idx] &gt; 0) {             food_times[idx]--             count++;             if(count == k) return (food_times.length &lt; idx+2 ? idx+2 - food_times.length : idx+2);         }     } }   결과      접근방식 및 아쉬웠던 점.   좋은 참고 사이트 : 참고사이트 Brute Force 문제였다. Object Array로 풀수있는 방법 중 좋은 방식을 생각하지 못했다. 루프를 진행하며 제외할수 있는 값을 계속 고려해서 루프를 돌았다. 그래서 불필요한 로직이 생겨버렸다.      내 정답들의 풀이 골격은 모두 다 해보는 Brute Force 알고리즘이다. 하지만 이렇게 하면 효율성 점수를 얻을 수 없다.      food_times 배열을 값과 인덱스로 Object Array을 만들고   각 줄마다 값이 있는 것들만 측정해서 k값을 지워나가고   k값이 0보다 클때 -1을 진행한다고 k=0이면 다음 요소로 넘어간다.     최고의 파이썬 답안   def solution(food_times, k):     if sum(food_times) &lt;= k: return -1     if len(food_times) &gt; k: return k+1ㅇ     n = len(food_times)     for i in range(n):         food_times[i] = [food_times[i],i+1]     ft = sorted(food_times,key=lambda x:x[0]) # 내림차순 정렬     i,r=0,0     while True:         if k - (n-i)*(ft[i][0]-r) &lt; 0:             break         else:             k -= (n-i)*(ft[i][0]-r)             r += (ft[i][0]-r)             i += 1     ft = sorted(ft[i:n], key = lambda x: x[1])     return ft[k%len(ft)][1]   결과      주요 로직 설명      food_times를 내림차순으로 정렬하여 가장 먼저 다 먹을 음식들 기준으로 정렬한다. =&gt; ft   ft를 순회하며(i += 1) 해당 시간만큼 남은 시간을 k(정전된시간)에 지속적으로 뺴준다. =&gt; k -= (n-i)*(ft[i][0]-r)   r에는 축적되는 시간을 계속 저장해둔다. =&gt; r += (ft[i][0]-r)        파이썬 답안을 보고 수정한 자바스크립트 답안   function solution(food_times, k) {     if(food_times.length &gt; k) return k+1;     if( food_times.reduce((a, b) =&gt; a + b) &lt;= k ) return -1;      const n = food_times.length;      for(let i=0;n&gt;i;i++) {         food_times[i] = [food_times[i],i+1];     }     let ft = food_times.sort((a, b) =&gt; a[0] - b[0]), // 내림차순 정렬         i = 0,         r = 0;     while(true) {         if( k-(n-i)*(ft[i][0]-r) &lt; 0 ) break;         else {             k -= (n-i)*(ft[i][0]-r);             r += ft[i][0]-r;             i += 1;         }     }     ft = food_times.slice(i,n).sort((a, b) =&gt; a[1] - b[1]);     return ft[k%ft.length][1]; }   결과        좋은 자바스크립트 답안   function solution(food_times, k) {   let copy = [],       total = 0;   for (let i = 0; i &lt; food_times.length; i++) {     total += food_times[i];     copy[i] = { val: food_times[i], index: i + 1 };   }    if (total &lt;= k) return -1;    copy.sort((a, b) =&gt; {     if (a.val === b.val) a.index - b.index;     return a.val - b.val;   });    let sum = 0;   let sub = 0;    for (let i = 0; i &lt; copy.length; i++) {     sub = (copy[i].val - sum) * (copy.length - i);     if (k - sub &gt;= 0) {       sum += copy[i].val - sum;       k -= sub;     } else {       let temp = Math.floor(k / (copy.length - i));       k -= temp * (copy.length - i);       sum += temp;       break;     }   }    copy = copy.filter(item =&gt; item.val - sum &gt; 0);   copy.sort((a, b) =&gt; a.index - b.index;);    return copy[k].index; }  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/KaKao-Eat-Live/",
        "teaser":null},{
        "title": "[GoogleAnalytics] 자기 자신의 활동기록 제외 (prevent recording myself)",
        "excerpt":"참고     5 ways to exclude your own visits from Google Analytics   How to exclude your own [dynamic] ip from Google Analytics   괜찮은 방법들     서버사이드나 백엔드 매서드            설명 : Dynamic DNS를 사용하여 IP를 제외. 과정이 복잡함. 회사에서 쓰기 적합.       장점 : 시스템으로 돌아감.       단점                    복잡하다.           캐시를 사용설정 해놓으면 무의미. DDNS 설정을 한 이후에도 설정전에 사이트에 접속한적이 있다면 혹시라도 남아있을 캐시는 제거하는 것이 필요.                           Google Analytics 필터로 Public IP 제외            과정 : GA(Google Analytics) 대쉬보드 -&gt; 관리 클릭 -&gt; 보기의 필터 클릭 -&gt; 필터 추가       장점 : 고정 IP만 쓰는 장치 제외에 적합.       단점 : 유동 IP이면 무의미. (핸드폰, 노트북 등 네트워크 전용선을 쓰지 않고 옮겨다니며 와이파이를 쓰는 경우)           브라우저 확장프로그램            설명 : 확장프로그램을 작동시켜 IP를 제외시킴.       장점 : 가장 간단.       단점 : 모바일, 테블릿에서 쓰지 못할수 있음.       추천 프로그램                    Google 웹로그 분석 차단 추가 기능(Google 제공)           Block Yourself from Analytics                          ","categories": ["GoogleAnalytics"],
        "tags": ["GoogleAnalytics"],
        "url": "https://seunghyum.github.io/googleanalytics/Google-Analytics-prevent-self/",
        "teaser":null},{
        "title": "[CodingTest] 2020 카카오 신입 공채 1차 - 2번 괄호 문자열 정제 문제 with Javascript",
        "excerpt":"  느낀점   재귀함수 문제. 지문을 그대로 코드로 변경하면 풀 수 있는 문제였음. 재귀함수에서 break를 제대로 안해서 시간이 지체됨.   내가 작성한 답변   function solution(s) {   return filterText(s) }  function filterText(s) {   if(s===\"\") return \"\";   let stats = {\"(\":0, \")\":0},       result = \"\";   for(let i=0;i&lt;s.length;i++){     if(s[i] === \"(\") stats[\"(\"]++;     else stats[\")\"]++;      if(stats[\"(\"] === stats[\")\"]) {       let u = s.substring(0,i+1),           v = s.substring(i+1,s.length) || \"\";       if(isRight(u)) result += u + filterText(v)       else {         if(v !== \"\") result += \"(\" +  filterText(v) + \")\";         result += filterWrongString(u);       }       break;     }   }   return result }    function isRight(u) {   if(u[0] == \")\") return false;   let stats = {\"(\":0, \")\":0};   for(let i=0;i&lt;u.length;i++){     if(u[i] === \"(\") stats[\"(\"]++;     else stats[\")\"]++;   }   if(stats[\"(\"] &lt; stats[\")\"]) return false;   return true; }  function filterWrongString(u) {   let result = \"\"   if(u.length !== 2) {     for(let i=0;i&lt;(u.length-2)/2;i++) {       result = \"(\".repeat((u.length-2)/2) + \")\".repeat((u.length-2)/2)     }   } else result = \"()\"   return result; }  console.log('solution(\"\") -&gt; result : ', solution(\"\"), \" Must be ''. It is \", solution(\"\") == \"\" ? \"Right\" : \"Wrong\") console.log(\"------------------\") console.log('solution(\"(()())()\") -&gt; result : ', solution(\"(()())()\"), \" Must be (()())(). It is \", solution(\"(()())()\") == \"(()())()\" ? \"Right\" : \"Wrong\") console.log(\"------------------\") console.log('solution(\")(\") -&gt; result : ', solution(\")(\"), \" Must be (). It is \", solution(\")(\") == \"()\" ? \"Right\" : \"Wrong\") console.log(\"------------------\") console.log('solution(\"()))((()\") -&gt; result : ', solution(\"()))((()\"), \" Must be ()(())(). It is \", solution(\"()))((()\") == \"()(())()\" ? \"Right\" : \"Wrong\")   ","categories": ["CodingTest"],
        "tags": ["Javascript","Recursion"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-Text-Bracket/",
        "teaser":null},{
        "title": "[CodingTest] 2020 카카오 신입 공채 1차 - 4번 정규표현식 문제 with Javascript",
        "excerpt":"  내가 작성한 답변   function solution(words, queries) {   let result = [];   for(let i=0;i&lt;queries.length;i++) {     let reg,         q = queries[i],         s = q.replace(/\\?/g,\"\");      result[i] = 0;      reg = new RegExp(`${s}`, \"g\");          for(let j=0;j&lt;words.length;j++) {       let w = words[j];        if(w.length !== q.length) continue;       if(w.match(reg)) {         result[i]+=1;       }     }   }   return result }  let w = [\"frodo\", \"front\", \"frost\", \"frozen\", \"frame\", \"kakao\"],     q = [\"fro??\", \"????o\", \"fr???\", \"fro???\", \"pro?\", \"?????\"];      console.log(` w = [\"frodo\", \"front\", \"frost\", \"frozen\", \"frame\", \"kakao\"], \\n q = [\"fro??\", \"????o\", \"fr???\", \"fro???\", \"pro?\", \"?????\"] \\n solution(w, q) -&gt; result : ${solution(w, q)} \\n Must be [ 3, 4, 4, 1, 0, 5 ]. \\n My answer is ${String(solution(w, q)) == String([ 3, 4, 4, 1, 0, 5 ]) ? \"Right\" : \"Wrong\"} `)  ","categories": ["CodingTest"],
        "tags": ["Javascript"],
        "url": "https://seunghyum.github.io/codingtest/Kakao-RegExp-Text/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트 1번",
        "excerpt":"1번 : 못품   제출한 답변   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   // 인풋 데이터 정제   const n = data.split(\" \"),     tmp = n[1].split(/\\n/),     mesages = Number(n[0]),     consumers = Number(tmp[0]);   tmp.shift()   const times = tmp;    let result = 0,     compare = [];      // 로직 수행을 위한 데이터 정제   for (let i = 0; i &lt; consumers; i++) {     let tmp = {}     tmp['index'] = i     tmp['time'] = 0     compare.push(tmp)   }    // 가장 낮은 time 값을 sort로 찾고 대기열의 숫자 추가    // A번   for (let i = 0; i &lt; times.length; i++) {     compare.sort((a, b) =&gt; a.time - b.time); // m * nlogn     compare[0].time += Number(times[i]);   }    // 최대값 추출   compare.sort((a, b) =&gt; b.time - a.time);  //  nlogn   console.log(String(compare[0].time)) });   느낀점   객체 배열(Obect Array)과 정렬(sort)로 푸려고함. 시간복잡도 O(nlogn) A번에서 좀 더 효율적인 알고리즘을 만들 수 없었을까. js 반복문 for, reduce, forEach, map, some, every 매서드들의 용도 다시 공부함.      for : array에 대한 반복이 아닌 횟수 반복을 적용하고자할 때 사용.   reduce : 깔대기에 물을 들이 붙는 것처럼 축적된 값(accumulator)를 반환. 비교할때, 축적된 값을 뽑을때 사용.   forEach : 함수를 순회함. index를 볼 수 있음. for문을 대체가능   map : 함수를 순회하며 인자를 다른 인자로 맵핑해서 새로운 array를 반환.   some : 배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트합니다.   every : 모든 요소들이 조건을 만족시키는지 확인.   수정한 답     // ...   // A번 수정   // 가장 낮은 time 값을 sort로 찾고 대기열의 숫자 추가   for (let i = 0; i &lt; times.length; i++) { // n     // compare.sort((a, b) =&gt; a.time - b.time);     // compare[0].time += Number(times[i]);     const target = compare.reduce((a,b) =&gt; a.time &gt; b.time ? b : a) // n*m     compare.forEach(e =&gt; {       if(target.index === e.index) e.time += Number(times[i])     }) // n*2m   }    // 최대값 추출   // compare.sort((a, b) =&gt; b.time - a.time);   // console.log(String(compare[0].time))   const answer = compare.reduce((a,b) =&gt; a.time &lt;b.time ? b : a)   console.log(String(answer.time)) })  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit-1/",
        "teaser":null},{
        "title": "[CodingTest] 2020 라인 SW개발 DEVEL-UP 인턴십 코드테스트 4번",
        "excerpt":"  4번 - 품   process.stdin.setEncoding('utf8'); process.stdin.on('data', data =&gt; {   const n = data.split(/\\n/);   const a = Number(n[0]),     b = n[1];   const sits = b.split(\" \");   let answer;    for (let i = 0; i &lt; sits.length; i++) {     if (sits[i] == \"1\") continue;     let right = 1,       left = 1;     loop:       for (let j = i; j &lt; sits.length; j++) {         if (!sits[j + 1] || sits[j + 1] == \"1\") break loop;         right++;         if (!sits[j - 1] || sits[j - 1] == \"1\") break loop;         left++;       }      let tmp = right &gt; left ? left : right;     if (!answer) answer = tmp;     else answer = answer &gt; tmp ? answer : tmp;   }   console.log(answer) });   내가 푼 방식   [1, 0, 1, 0, 0, 0, 1] 중 0인 값들만 선택적으로 골라 i-1, i+1인 곳을 찾아 통계를 매김.   다시 생각한 방식      1과 0이 이어지는 곳 중 0이 가장 많이 이어지는 곳들을 찾고   해당 구간의 중간을 찾아 좌우 거리를 측정 했다면 시간 복잡도를 더 줄일 수 있을 것 같음.   function solution(data) {   const n = data.split(/\\n/),         a = Number(n[0]),         b = n[1];   const sits = b.split(\" \");   let answer,       maxLength=0,       maxLengthStartIndex=0;    for (let i = 0; i &lt; sits.length; i++) {     console.log(\"iiiiiii : \",i)     if (sits[i] == \"1\") continue;     else {       let checkLength=0,           checkIndex=i;       loop:       for(let j=1;j&lt;sits.length-i;j++) {         if(sits[i+j]==\"1\") {           if(maxLength &lt; checkLength) {             i+=j // 계산한 값들은 건너뛰어서 측정             maxLength = checkLength             maxLengthStartIndex = checkIndex           }           break loop;         } else {           checkLength+=1         }       }     }   }   if(maxLength%2 == 0) answer = Math.floor(maxLength/2)+1   else answer = Math.floor(maxLength/2)   console.log(answer) } solution(`8 1 0 1 0 0 0 0 1`)  ","categories": ["CodingTest"],
        "tags": ["Javascript","NaverHackDay"],
        "url": "https://seunghyum.github.io/codingtest/Line-recruit-4/",
        "teaser":null}]
